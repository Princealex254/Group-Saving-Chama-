<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chama Admin Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Chart.js for Charts -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Custom styles for the theme colors and fonts */
        :root {
            --primary-maroon: #800000;
            --secondary-white: #ffffff;
            --dark-gray: #333;
            --light-gray: #f4f4f4;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-gray); /* Light gray for body background */
            margin: 0;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .bg-maroon { background-color: var(--primary-maroon); }
        .text-maroon { color: var(--primary-maroon); }
        .border-maroon { border-color: var(--primary-maroon); }
        .btn-primary {
            background-color: var(--primary-maroon);
            color: var(--secondary-white);
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
        }
        .btn-primary:hover { background-color: #a00000; }

        .btn-secondary { /* Example for other actions like Deactivate/Reject */
            background-color: #6B7280; /* Gray */
            color: var(--secondary-white);
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
        }
        .btn-secondary:hover { background-color: #4B5563; }

        .btn-danger { /* Example for Delete */
            background-color: #EF4444; /* Red */
            color: var(--secondary-white);
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.3s ease;
        }
        .btn-danger:hover { background-color: #DC2626; }

        .link-maroon {
            color: var(--primary-maroon);
            text-decoration: none;
        }
        .link-maroon:hover { text-decoration: underline; }
        .input-field {
            padding: 0.75rem 1rem;
            border: 1px solid #ccc;
            border-radius: 0.5rem;
            width: 100%;
            box-sizing: border-box;
        }
        .message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #4CAF50;
            color: white;
            padding: 15px;
            border-radius: 8px;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease-in-out, visibility 0.5s ease-in-out;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .message-box.error { background-color: #f44336; }
        .message-box.show { opacity: 1; visibility: visible; }
        .message-box-content { flex-grow: 1; padding-right: 10px; }
        .message-box-close {
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.2s;
        }
        .message-box-close:hover { background-color: rgba(255, 255, 255, 0.2); }

        /* Admin specific styles */
        .admin-header {
            background-color: var(--primary-maroon);
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: fixed;
            width: 100%;
            top: 0;
            z-index: 50;
        }
        .admin-sidebar {
            width: 250px;
            background-color: var(--dark-gray); /* Dark gray sidebar */
            color: white;
            padding-top: 5rem; /* Space for fixed header */
            position: fixed;
            height: 100%;
            overflow-y: auto;
            transform: translateX(-100%);
            transition: transform 0.3s ease-in-out;
            z-index: 40;
        }
        .admin-sidebar.open { transform: translateX(0); }
        .admin-sidebar-item {
            display: flex;
            align-items: center;
            padding: 1rem 1.5rem;
            font-size: 1.1rem;
            border-bottom: 1px solid #444;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        .admin-sidebar-item i { margin-right: 0.75rem; }
        .admin-sidebar-item:hover { background-color: #555; }
        .admin-sidebar-item.active {
            background-color: #555;
            color: var(--primary-maroon); /* Highlight active link */
        }
        .admin-main-content {
            flex-grow: 1;
            margin-left: 0;
            padding: 1rem;
            padding-top: 5rem; /* Space for fixed header */
            transition: margin-left 0.3s ease-in-out;
        }
        @media (min-width: 768px) {
            .admin-sidebar { transform: translateX(0); } /* Always open on desktop */
            .admin-main-content { margin-left: 250px; } /* Offset for sidebar */
            .admin-header { padding-left: 266px; } /* Adjust header for sidebar width */
        }

        /* Tables styling */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-radius: 0.5rem;
            overflow: hidden; /* Ensures rounded corners are applied */
        }
        .data-table th, .data-table td {
            padding: 0.75rem 1rem;
            border: 1px solid #e2e8f0;
            text-align: left;
        }
        .data-table th {
            background-color: var(--primary-maroon);
            color: var(--secondary-white);
            font-weight: bold;
        }
        .data-table tr:nth-child(even) { /* Alternating row colors */
            background-color: #f8f8f8;
        }
        .data-table tr:hover {
            background-color: #f0f0f0;
        }
        .data-table td.actions {
            white-space: nowrap; /* Keep buttons on one line */
        }

        .scroll-y {
            max-height: calc(100vh - 250px); /* Adjust based on header/footer/other elements */
            overflow-y: auto;
            background-color: white; /* Ensure background for scrollable areas */
            padding: 1rem;
            border-radius: 0.5rem;
        }

        /* Custom Modal for Confirmation */
        .custom-modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        .custom-modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .custom-modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px; /* Increased max-width for forms */
            text-align: center;
            transform: translateY(20px);
            opacity: 0;
            transition: transform 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        .custom-modal-overlay.show .custom-modal-content {
            transform: translateY(0);
            opacity: 1;
        }
        .custom-modal-content h3 {
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-maroon);
            margin-bottom: 1rem;
        }
        .custom-modal-content p {
            margin-bottom: 1.5rem;
            color: #333;
        }
        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 1rem;
        }
        .custom-modal-buttons button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .custom-modal-buttons .confirm-btn {
            background-color: var(--primary-maroon);
            color: white;
        }
        .custom-modal-buttons .confirm-btn:hover {
            background-color: #a00000;
        }
        .custom-modal-buttons .cancel-btn {
            background-color: #ccc;
            color: #333;
        }
        .custom-modal-buttons .cancel-btn:hover {
            background-color: #bbb;
        }

        /* Modal specific styling for forms */
        .modal-form-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
        }
        @media (min-width: 640px) {
            .modal-form-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        .modal-form-grid .full-width {
            grid-column: 1 / -1;
        }
        .modal-form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1.5rem;
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #eee;
        }
        .modal-close-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
        }
        .modal-close-btn:hover {
            color: #333;
        }

        /* Login page specific styles */
        .login-container {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: var(--light-gray);
            padding: 2rem;
        }
        .login-box {
            background-color: var(--secondary-white);
            padding: 2.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 450px;
            border-top: 5px solid var(--primary-maroon);
            text-align: center;
        }
        .login-box h2 {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-maroon);
            margin-bottom: 1.5rem;
        }
        .login-box .status-indicator {
            font-size: 0.9rem;
            color: #666;
            margin-bottom: 1rem;
        }
        /* Dashboard Charts */
        .chart-container {
            background-color: white;
            padding: 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">
    <!-- Login Page -->
    <div id="login-page" class="login-container">
        <div class="login-box">
            <h2>Chama Admin Login</h2>
            <p id="connection-status" class="status-indicator">Connecting to Firebase...</p>
            <form id="admin-login-form" class="space-y-4">
                <div>
                    <label for="admin-login-email" class="block text-gray-700 text-sm font-bold mb-2 text-left">Email</label>
                    <input type="email" id="admin-login-email" class="input-field" placeholder="admin@example.com" required>
                </div>
                <div>
                    <label for="admin-login-password" class="block text-gray-700 text-sm font-bold mb-2 text-left">Password</label>
                    <input type="password" id="admin-login-password" class="input-field" placeholder="Your password" required>
                </div>
                <button type="submit" class="btn-primary w-full">Login</button>
            </form>
        </div>
    </div>

    <!-- Admin Dashboard (Hidden by default, shown after login) -->
    <div id="admin-dashboard-container" class="hidden flex flex-col flex-grow">
        <!-- Admin Header -->
        <header class="admin-header">
            <div class="flex items-center space-x-4">
                <button id="hamburger-menu" class="text-white md:hidden focus:outline-none">
                    <i class="fas fa-bars text-2xl"></i>
                </button>
                <span class="text-2xl font-bold">Chama Admin Panel</span>
            </div>
            <div class="flex items-center space-x-4">
                <span id="admin-user-display" class="text-lg"></span>
                <button id="admin-logout-button" class="btn-primary px-4 py-2 text-sm">Logout</button>
            </div>
        </header>

        <div class="flex flex-grow" style="padding-top: 4rem;"> <!-- Offset for fixed header -->
            <!-- Admin Sidebar -->
            <nav id="admin-sidebar" class="admin-sidebar">
                <div class="py-4">
                    <a href="#admin-dashboard" class="admin-sidebar-item" data-page="admin-dashboard">
                        <i class="fas fa-tachometer-alt"></i>Dashboard Overview
                    </a>
                    <a href="#manage-users" class="admin-sidebar-item" data-page="manage-users">
                        <i class="fas fa-users"></i>Manage Members
                    </a>
                    <a href="#manage-contributions" class="admin-sidebar-item" data-page="manage-contributions">
                        <i class="fas fa-money-bill-wave"></i>Contributions
                    </a>
                    <a href="#manage-loans" class="admin-sidebar-item" data-page="manage-loans">
                        <i class="fas fa-hand-holding-usd"></i>Loans
                    </a>
                    <a href="#manage-meetings" class="admin-sidebar-item" data-page="manage-meetings">
                        <i class="fas fa-calendar-alt"></i>Meetings & Notices
                    </a>
                    <a href="#manage-investments" class="admin-sidebar-item" data-page="manage-investments">
                        <i class="fas fa-chart-line"></i>Investments
                    </a>
                    <a href="#manage-polls" class="admin-sidebar-item" data-page="manage-polls">
                        <i class="fas fa-vote-yea"></i>Voting & Polls
                    </a>
                    <a href="#manage-documents" class="admin-sidebar-item" data-page="manage-documents">
                        <i class="fas fa-folder-open"></i>Documents
                    </a>
                    <a href="#manage-fines" class="admin-sidebar-item" data-page="manage-fines">
                        <i class="fas fa-gavel"></i>Fines & Penalties
                    </a>
                    <a href="#manage-attendance" class="admin-sidebar-item" data-page="manage-attendance">
                        <i class="fas fa-clipboard-check"></i>Attendance
                    </a>
                    <a href="#manage-notifications" class="admin-sidebar-item" data-page="manage-notifications">
                        <i class="fas fa-bell"></i>Notifications
                    </a>
                    <a href="#reports" class="admin-sidebar-item" data-page="reports">
                        <i class="fas fa-chart-bar"></i>Reports
                    </a>
                    <a href="#admin-settings" class="admin-sidebar-item" data-page="admin-settings">
                        <i class="fas fa-cogs"></i>Admin Settings
                    </a>
                </div>
            </nav>

            <!-- Admin Main Content -->
            <main id="admin-app-content" class="admin-main-content">
                <!-- Content will be dynamically loaded here by JavaScript -->
            </main>
        </div>
    </div>

    <!-- Message Box -->
    <div id="message-box" class="message-box">
        <span id="message-box-content" class="message-box-content"></span>
        <button id="message-box-close" class="message-box-close">
            <i class="fas fa-times"></i>
        </button>
    </div>

    <!-- Custom Confirmation Modal -->
    <div id="custom-confirm-modal" class="custom-modal-overlay">
        <div class="custom-modal-content">
            <h3 id="custom-confirm-title">Confirm Action</h3>
            <p id="custom-confirm-message">Are you sure you want to perform this action?</p>
            <div class="custom-modal-buttons">
                <button class="confirm-btn" id="custom-confirm-yes">Yes</button>
                <button class="cancel-btn" id="custom-confirm-no">No</button>
            </div>
        </div>
    </div>

    <!-- Generic Add/Edit Modal (will be dynamically populated) -->
    <div id="data-modal-overlay" class="custom-modal-overlay">
        <div class="custom-modal-content">
            <div class="modal-header">
                <h3 id="data-modal-title"></h3>
                <button class="modal-close-btn" id="data-modal-close"><i class="fas fa-times"></i></button>
            </div>
            <form id="data-modal-form" class="modal-form-grid"></form>
            <div class="modal-form-actions">
                <button type="button" class="btn-secondary" id="data-modal-cancel">Cancel</button>
                <button type="submit" class="btn-primary" id="data-modal-submit">Save</button>
            </div>
        </div>
    </div>

    <!-- Firebase Config Injection -->
    <script>
        // Your Firebase project configuration - MUST MATCH index.html
        var __firebase_config = JSON.stringify({
            apiKey: "AIzaSyC8-TWRr_vOMTv72scXxu-9l5uVHRVputo",
            authDomain: "group-saving-chama.firebaseapp.com",
            projectId: "group-saving-chama",
            storageBucket: "group-saving-chama.appspot.com",
            messagingSenderId: "570981365925",
            appId: "1:570981365925:web:42422e51e4e02c6ab4f54c"
        });

        // Your App ID - MUST MATCH index.html
        var __app_id = "group-saving-chama";
    </script>

    <!-- Firebase SDKs and Admin Application Logic -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged, setPersistence, browserLocalPersistence } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, updateDoc, collection, addDoc, query, orderBy, onSnapshot, serverTimestamp, runTransaction, getDocs, deleteDoc, collectionGroup, where } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL, deleteObject } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-storage.js";

        document.addEventListener("DOMContentLoaded", () => {
            let app;
            let auth;
            let db;
            let storage; // Firebase Storage instance
            let currentAdminId = null; // Will store the UID of the logged-in admin
            let currentAdminEmail = null; // Will store the email of the logged-in admin
            let currentDataModalItem = null; // Stores data of item being edited/added in generic modal
            let currentDataModalCollection = ''; // Stores collection name for generic modal

            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            // Firebase Helper Functions (Consistent with main page)
            function getPublicCollectionPath(collectionName) {
              return `artifacts/${appId}/public/data/${collectionName}`;
            }

            function getPrivateCollectionPath(userId, collectionName) {
              return `artifacts/${appId}/users/${userId}/${collectionName}`;
            }

            // --- UI Elements ---
            const loginPage = document.getElementById('login-page');
            const adminDashboardContainer = document.getElementById('admin-dashboard-container');
            const adminLoginForm = document.getElementById('admin-login-form');
            const adminLoginEmail = document.getElementById('admin-login-email');
            const adminLoginPassword = document.getElementById('admin-login-password');
            const connectionStatus = document.getElementById('connection-status');
            const adminUserDisplay = document.getElementById('admin-user-display');
            const adminLogoutButton = document.getElementById('admin-logout-button');
            const hamburgerMenu = document.getElementById('hamburger-menu');
            const adminSidebar = document.getElementById('admin-sidebar');
            const adminAppContent = document.getElementById('admin-app-content');
            const messageBoxCloseButton = document.getElementById('message-box-close');
            const dataModalOverlay = document.getElementById('data-modal-overlay');
            const dataModalTitle = document.getElementById('data-modal-title');
            const dataModalForm = document.getElementById('data-modal-form');
            const dataModalCloseBtn = document.getElementById('data-modal-close');
            const dataModalCancelBtn = document.getElementById('data-modal-cancel');
            const dataModalSubmitBtn = document.getElementById('data-modal-submit');

            // --- Global State & Listeners Management ---
            let unsubscribeListeners = []; // Array to store Firestore unsubscribe functions

            // Function to unsubscribe all active listeners
            function unsubscribeAllListeners() {
                unsubscribeListeners.forEach(unsub => unsub());
                unsubscribeListeners = [];
                console.log("All Firestore listeners unsubscribed.");
            }

            // --- Message Box Functions ---
            function showMessage(message, type = 'success') {
                const msgBox = document.getElementById('message-box');
                const msgBoxContent = document.getElementById('message-box-content');
                msgBoxContent.textContent = message;
                msgBox.className = `message-box ${type}`;
                setTimeout(() => msgBox.classList.add('show'), 10);
            }

            function hideMessageBox() {
                const msgBox = document.getElementById('message-box');
                msgBox.classList.remove('show');
                setTimeout(() => msgBox.className = 'message-box', 500);
            }
            messageBoxCloseButton.addEventListener('click', hideMessageBox);

            // --- Custom Confirmation Modal Logic ---
            const customConfirmModal = document.getElementById('custom-confirm-modal');
            const customConfirmTitle = document.getElementById('custom-confirm-title');
            const customConfirmMessage = document.getElementById('custom-confirm-message');
            const customConfirmYes = document.getElementById('custom-confirm-yes');
            const customConfirmNo = document.getElementById('custom-confirm-no');

            let resolveConfirmPromise;
            function showCustomConfirm(title, message) {
                customConfirmTitle.textContent = title;
                customConfirmMessage.textContent = message;
                customConfirmModal.classList.add('show');
                return new Promise((resolve) => {
                    resolveConfirmPromise = resolve;
                });
            }

            function hideCustomConfirm() {
                customConfirmModal.classList.remove('show');
            }

            customConfirmYes.addEventListener('click', () => { hideCustomConfirm(); resolveConfirmPromise(true); });
            customConfirmNo.addEventListener('click', () => { hideCustomConfirm(); resolveConfirmPromise(false); });

            // --- Generic Data Modal Logic (Add/Edit) ---
            function openDataModal(title, collectionName, item = null) {
                dataModalTitle.textContent = title;
                dataModalForm.innerHTML = ''; // Clear previous form fields
                currentDataModalItem = item;
                currentDataModalCollection = collectionName;

                let fields = [];
                switch (collectionName) {
                    case 'users': // For adding/editing members (from Auth, then profile)
                        fields = [
                            { id: 'member-name', label: 'Full Name', type: 'text', required: true, value: item?.name || '' },
                            { id: 'member-email', label: 'Email', type: 'email', required: true, value: item?.email || '' },
                            { id: 'member-password', label: 'Password (for new members)', type: 'password', required: !item, minlength: 6 },
                            { id: 'member-phone', label: 'Phone Number', type: 'tel', required: true, value: item?.phone || '', pattern: "^\\+?\\d{10,14}$" },
                            { id: 'member-national-id', label: 'National ID', type: 'text', required: true, value: item?.nationalId || '' },
                            { id: 'member-profile-pic', label: 'Profile Picture URL', type: 'url', value: item?.profilePicUrl || '' },
                            { id: 'member-status', label: 'Status', type: 'select', options: ['pending', 'approved', 'deactivated', 'admin'], value: item?.status || 'pending' },
                        ];
                        // If editing, email and password might not be directly editable through this form.
                        // Email is handled via Auth, not Firestore profile. Password only for create.
                        if (item) {
                            fields.find(f => f.id === 'member-email').disabled = true;
                            fields = fields.filter(f => f.id !== 'member-password');
                        }
                        break;
                    case 'contributions':
                        fields = [
                            { id: 'contribution-member-id', label: 'Member ID (UID)', type: 'text', required: true, value: item?.memberId || '', disabled: !!item },
                            { id: 'contribution-amount', label: 'Amount (KSh)', type: 'number', required: true, min: 1, value: item?.amount || '' },
                            { id: 'contribution-method', label: 'Method', type: 'select', options: ['M-Pesa', 'Bank Transfer', 'Cash'], required: true, value: item?.method || '' },
                            { id: 'contribution-description', label: 'Description', type: 'text', value: item?.description || '' },
                            { id: 'contribution-date', label: 'Date', type: 'date', required: true, value: item?.date ? new Date(item.date.seconds * 1000).toISOString().split('T')[0] : new Date().toISOString().split('T')[0] },
                        ];
                        break;
                    case 'loans':
                        fields = [
                            { id: 'loan-member-id', label: 'Member ID (UID)', type: 'text', required: true, value: item?.memberId || '', disabled: !!item },
                            { id: 'loan-amount', label: 'Amount (KSh)', type: 'number', required: true, min: 1, value: item?.amount || '' },
                            { id: 'loan-interest-rate', label: 'Interest Rate (%)', type: 'number', required: true, min: 0, max: 100, step: 0.1, value: item?.interestRate || 0 },
                            { id: 'loan-due-date', label: 'Due Date', type: 'date', required: true, value: item?.dueDate ? new Date(item.dueDate.seconds * 1000).toISOString().split('T')[0] : '' },
                            { id: 'loan-repayment-plan', label: 'Repayment Plan', type: 'select', options: ['3 Months', '6 Months', '12 Months'], required: true, value: item?.repaymentPlan || '' },
                            { id: 'loan-purpose', label: 'Purpose', type: 'textarea', required: true, value: item?.purpose || '' },
                            { id: 'loan-status', label: 'Status', type: 'select', options: ['pending', 'approved', 'rejected', 'completed'], required: true, value: item?.status || 'pending' },
                        ];
                        break;
                    case 'meetings':
                        fields = [
                            { id: 'meeting-title', label: 'Title', type: 'text', required: true, value: item?.title || '' },
                            { id: 'meeting-date', label: 'Date', type: 'date', required: true, value: item?.date ? new Date(item.date.seconds * 1000).toISOString().split('T')[0] : '' },
                            { id: 'meeting-time', label: 'Time', type: 'time', required: true, value: item?.time || '' },
                            { id: 'meeting-location', label: 'Location', type: 'text', required: true, value: item?.location || '' },
                            { id: 'meeting-description', label: 'Description', type: 'textarea', value: item?.description || '' },
                            { id: 'meeting-type', label: 'Type', type: 'select', options: ['meeting', 'notice'], required: true, value: item?.type || 'meeting' },
                        ];
                        break;
                    case 'investments':
                        fields = [
                            { id: 'investment-title', label: 'Title', type: 'text', required: true, value: item?.title || '' },
                            { id: 'investment-amount', label: 'Goal Amount (KSh)', type: 'number', required: true, min: 1, value: item?.amount || '' },
                            { id: 'investment-description', label: 'Description', type: 'textarea', required: true, value: item?.description || '' },
                            { id: 'investment-estimated-return', label: 'Estimated Return', type: 'text', value: item?.estimatedReturn || 'N/A' },
                            { id: 'investment-status', label: 'Status', type: 'select', options: ['active', 'completed', 'cancelled'], required: true, value: item?.status || 'active' },
                        ];
                        break;
                    case 'polls':
                        fields = [
                            { id: 'poll-title', label: 'Poll Question', type: 'text', required: true, value: item?.title || '' },
                            { id: 'poll-options', label: 'Options (comma-separated)', type: 'text', required: true, value: Array.isArray(item?.options) ? item.options.join(', ') : '' },
                            { id: 'poll-description', label: 'Description (Optional)', type: 'textarea', value: item?.description || '' },
                            { id: 'poll-status', label: 'Status', type: 'select', options: ['active', 'closed'], required: true, value: item?.status || 'active' },
                        ];
                        // Votes are not edited directly via form.
                        break;
                    case 'documents':
                        fields = [
                            { id: 'document-title', label: 'Document Title', type: 'text', required: true, value: item?.title || '' },
                            { id: 'document-file-input', label: 'Upload File (or paste URL)', type: 'file' }, // File input
                            { id: 'document-file-url', label: 'Direct File URL', type: 'url', value: item?.fileUrl || '' },
                        ];
                        // For editing, if file is uploaded, URL updates. If new file uploaded, old URL replaced.
                        break;
                    case 'fines':
                        fields = [
                            { id: 'fine-member-id', label: 'Member ID (UID)', type: 'text', required: true, value: item?.memberId || '', disabled: !!item },
                            { id: 'fine-amount', label: 'Amount (KSh)', type: 'number', required: true, min: 1, value: item?.amount || '' },
                            { id: 'fine-reason', label: 'Reason', type: 'textarea', required: true, value: item?.reason || '' },
                            { id: 'fine-status', label: 'Status', type: 'select', options: ['unpaid', 'paid'], required: true, value: item?.status || 'unpaid' },
                            { id: 'fine-date-issued', label: 'Date Issued', type: 'date', required: true, value: item?.dateIssued ? new Date(item.dateIssued.seconds * 1000).toISOString().split('T')[0] : new Date().toISOString().split('T')[0] },
                        ];
                        break;
                    case 'attendance':
                        fields = [
                            { id: 'attendance-date', label: 'Meeting Date', type: 'date', required: true, value: new Date().toISOString().split('T')[0] },
                            { id: 'attendance-members', label: 'Select Members (Ctrl+Click to select multiple)', type: 'select-multiple', options: [], required: true },
                        ];
                        // Populate member options dynamically
                        loadMemberOptionsForAttendance();
                        if (item) { // For editing existing attendance records, which is more complex if it's a bulk record
                            showMessage("Editing individual attendance records is not fully supported via this modal. Use delete and re-add for simplicity.", "info");
                            return; // Don't proceed with rendering form for edit attendance
                        }
                        break;
                    case 'notifications':
                        fields = [
                            { id: 'notification-subject', label: 'Subject', type: 'text', required: true, value: item?.title || '' },
                            { id: 'notification-message', label: 'Message', type: 'textarea', required: true, value: item?.message || '' },
                            { id: 'notification-recipients', label: 'Recipients', type: 'select', options: ['All Members', 'Specific Member'], required: true, value: 'All Members' },
                            { id: 'notification-specific-member-id', label: 'Specific Member ID (UID)', type: 'text', placeholder: 'Enter UID if "Specific Member"', class: 'hidden' },
                        ];
                        break;
                }

                fields.forEach(field => {
                    const div = document.createElement('div');
                    div.className = field.class || ''; // Apply custom classes like 'hidden'
                    const label = `<label for="${field.id}" class="block text-gray-700 text-sm font-bold mb-2 text-left">${field.label}</label>`;
                    let inputHtml = '';

                    if (field.type === 'select') {
                        inputHtml = `<select id="${field.id}" class="input-field" ${field.required ? 'required' : ''} ${field.disabled ? 'disabled' : ''}>`;
                        field.options.forEach(opt => {
                            const value = opt.toLowerCase().replace(/ /g, '-');
                            inputHtml += `<option value="${value}" ${field.value === value ? 'selected' : ''}>${opt}</option>`;
                        });
                        inputHtml += `</select>`;
                    } else if (field.type === 'select-multiple') {
                        inputHtml = `<select id="${field.id}" class="input-field" multiple size="5" ${field.required ? 'required' : ''} ${field.disabled ? 'disabled' : ''}>`;
                         // Options will be dynamically populated in loadMemberOptionsForAttendance()
                        inputHtml += `</select>`;
                    } else if (field.type === 'textarea') {
                        inputHtml = `<textarea id="${field.id}" class="input-field h-24" placeholder="${field.placeholder || ''}" ${field.required ? 'required' : ''} ${field.disabled ? 'disabled' : ''}>${field.value || ''}</textarea>`;
                    } else if (field.type === 'file') {
                         inputHtml = `
                            <input type="file" id="${field.id}" class="input-field border-none shadow-none" ${field.required ? 'required' : ''}>
                            ${item?.fileUrl ? `<p class="text-xs text-gray-500 mt-1">Current File: <a href="${item.fileUrl}" target="_blank" class="link-maroon">View</a></p>` : ''}
                        `;
                    }
                    else {
                        inputHtml = `<input type="${field.type}" id="${field.id}" class="input-field" placeholder="${field.placeholder || ''}" value="${field.value || ''}" ${field.required ? 'required' : ''} ${field.minlength ? `minlength="${field.minlength}"` : ''} ${field.min ? `min="${field.min}"` : ''} ${field.max ? `max="${field.max}"` : ''} ${field.step ? `step="${field.step}"` : ''} ${field.pattern ? `pattern="${field.pattern}"` : ''} ${field.disabled ? 'disabled' : ''}>`;
                    }
                    div.innerHTML = label + inputHtml;
                    dataModalForm.appendChild(div);
                });

                // Specific listeners for notification modal to toggle specific member ID input
                if (collectionName === 'notifications') {
                    const recipientsSelect = document.getElementById('notification-recipients');
                    const specificMemberIdInput = document.getElementById('notification-specific-member-id');
                    recipientsSelect.addEventListener('change', () => {
                        if (recipientsSelect.value === 'specific-member') {
                            specificMemberIdInput.classList.remove('hidden');
                            specificMemberIdInput.required = true;
                        } else {
                            specificMemberIdInput.classList.add('hidden');
                            specificMemberIdInput.required = false;
                        }
                    });
                     // Load existing members for specific member selection (if type is 'Specific Member')
                    loadMemberOptionsForNotification();
                    if (item && item.recipientId) { // If editing a notification sent to a specific member
                        recipientsSelect.value = 'specific-member';
                        specificMemberIdInput.classList.remove('hidden');
                        specificMemberIdInput.value = item.recipientId;
                        specificMemberIdInput.required = true;
                    }
                }

                dataModalOverlay.classList.add('show');
            }

            async function loadMemberOptionsForNotification() {
                const specificMemberIdInput = document.getElementById('notification-specific-member-id');
                if (!specificMemberIdInput) return;

                try {
                    const allUsersSnapshot = await getDocs(query(collectionGroup(db, 'user_profile'), orderBy('name')));
                    // Convert input to a datalist for type-ahead search
                    let datalist = document.getElementById('member-ids-datalist');
                    if (!datalist) {
                        datalist = document.createElement('datalist');
                        datalist.id = 'member-ids-datalist';
                        document.body.appendChild(datalist);
                        specificMemberIdInput.setAttribute('list', 'member-ids-datalist');
                    }
                    datalist.innerHTML = ''; // Clear previous options
                    allUsersSnapshot.forEach(doc => {
                        const user = doc.data();
                        const option = document.createElement('option');
                        option.value = doc.id; // User UID
                        option.textContent = `${user.name} (${user.email})`;
                        datalist.appendChild(option);
                    });
                } catch (error) {
                    console.error("Error loading member options for notification:", error);
                    showMessage("Failed to load member list for notifications.", "error");
                }
            }


            async function loadMemberOptionsForAttendance() {
                const attendanceMembersSelect = document.getElementById('attendance-members');
                if (!attendanceMembersSelect) return;

                try {
                    const allUsersSnapshot = await getDocs(query(collectionGroup(db, 'user_profile'), orderBy('name')));
                    attendanceMembersSelect.innerHTML = ''; // Clear previous options
                    allUsersSnapshot.forEach(doc => {
                        const user = doc.data();
                        const option = document.createElement('option');
                        option.value = doc.id; // User UID
                        option.textContent = `${user.name} (${user.email}) - Status: ${user.status}`;
                        attendanceMembersSelect.appendChild(option);
                    });
                } catch (error) {
                    console.error("Error loading member options for attendance:", error);
                    showMessage("Failed to load member list for attendance.", "error");
                }
            }


            function hideDataModal() {
                dataModalOverlay.classList.remove('show');
                dataModalForm.reset(); // Reset form fields
                currentDataModalItem = null;
                currentDataModalCollection = '';
            }

            dataModalCloseBtn.addEventListener('click', hideDataModal);
            dataModalCancelBtn.addEventListener('click', hideDataModal);
            dataModalSubmitBtn.addEventListener('click', (event) => {
                event.preventDefault(); // Prevent default form submission
                handleDataModalSubmit();
            });

            // --- Firebase Initialization & Auth State ---
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            storage = getStorage(app);

            // Set session persistence
            setPersistence(auth, browserLocalPersistence)
                .then(() => {
                    console.log("Auth persistence set to local.");
                    // onAuthStateChanged will trigger after this.
                })
                .catch((error) => {
                    console.error("Error setting auth persistence:", error);
                });

            /**
             * Checks if a given user's email corresponds to an admin record in Firestore.
             * @param {string} userEmail The email of the authenticated user.
             * @returns {Promise<boolean>} True if the user is an admin, false otherwise.
             */
            async function checkAdminStatus(userEmail) {
                if (!userEmail) {
                    console.warn("No user email provided to checkAdminStatus.");
                    return false;
                }
                const adminRef = doc(db, 'admins', userEmail.toLowerCase()); // Check root-level 'admins' collection
                try {
                    const adminDoc = await getDoc(adminRef);
                    if (adminDoc.exists() && adminDoc.data().isAdmin === true) {
                        return true;
                    } else {
                        return false;
                    }
                } catch (error) {
                    console.error("Error checking admin status:", error);
                    // For security, if there's an error checking, assume not admin.
                    return false;
                }
            }

            onAuthStateChanged(auth, async (user) => {
                unsubscribeAllListeners(); // Always clear listeners on auth state change

                if (user) {
                    currentAdminId = user.uid;
                    currentAdminEmail = user.email; // Store the email
                    adminUserDisplay.textContent = `Loading... (${user.email})`; // Temporary display

                    const isAdmin = await checkAdminStatus(user.email); // Pass email for new admin check

                    if (isAdmin) {
                        console.log("Admin logged in:", user.email);
                        loginPage.classList.add('hidden');
                        adminDashboardContainer.classList.remove('hidden');
                        connectionStatus.textContent = "Connected (Admin)";
                        adminUserDisplay.textContent = `Admin: ${user.email}`; // Display actual admin email
                        initAdminListeners();
                        renderAdminSubpage(window.location.hash.substring(1) || 'admin-dashboard'); // Render based on hash or default
                    } else {
                        console.warn("User is not an admin. Redirecting to main login.");
                        showMessage("Access Denied: You must be an administrator to view this page.", "error");
                        connectionStatus.textContent = "Access Denied";

                        // Immediately log out the non-admin user
                        try {
                            await signOut(auth);
                            console.log("Non-admin user logged out.");
                        } catch (logoutError) {
                            console.error("Error during non-admin logout:", logoutError);
                        }
                        // Redirect to main site's home or login page if not admin
                        window.location.replace(window.location.origin + '/index.html#login');
                    }
                } else {
                    currentAdminId = null;
                    currentAdminEmail = null; // Clear email on logout
                    adminUserDisplay.textContent = 'Not Logged In';
                    console.log("No user signed in. Showing login page.");
                    loginPage.classList.remove('hidden');
                    adminDashboardContainer.classList.add('hidden');
                    connectionStatus.textContent = "Disconnected (Not Authenticated)";
                    adminLoginForm.reset(); // Clear login form on logout
                }
            });

            // --- Admin Login & Logout ---
            adminLoginForm.addEventListener('submit', async (event) => {
                event.preventDefault();
                const email = adminLoginEmail.value.trim();
                const password = adminLoginPassword.value;

                if (!email || !password) {
                    showMessage("Email and password are required.", "error");
                    return;
                }

                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    showMessage("Login successful! Checking admin privileges...", "success");
                    // onAuthStateChanged will handle redirection after admin check
                } catch (error) {
                    console.error("Error during admin login:", error);
                    let errorMessage = "Login failed. Invalid credentials.";
                    if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password' || error.code === 'auth/invalid-credential') {
                        errorMessage = "Invalid email or password.";
                    } else if (error.code === 'auth/too-many-requests') {
                        errorMessage = "Too many login attempts. Please try again later.";
                    }
                    showMessage(errorMessage, "error");
                }
            });

            adminLogoutButton.addEventListener('click', async () => {
                try {
                    await signOut(auth);
                    showMessage("Admin logged out successfully.", "success");
                    // onAuthStateChanged will handle showing the login page
                } catch (error) {
                    console.error("Error logging out admin:", error);
                    showMessage("Failed to log out.", "error");
                }
            });

            // --- Core Admin Dashboard Functionality ---

            // Admin-specific listeners (grouped for easy management)
            function initAdminListeners() {
                // No global real-time listeners at this level, they are managed per subpage.
                // This function is mainly for any initial setup that needs to happen once admin is confirmed.
                console.log("Admin listeners initialized.");
            }

            // Toggle mobile sidebar
            hamburgerMenu.addEventListener('click', () => {
                adminSidebar.classList.toggle('open');
            });

            // Admin Subpage Content Definitions
            const adminSubpages = {
                'admin-dashboard': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Admin Dashboard Overview</h2>
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                        <div class="bg-gray-100 p-4 rounded-lg shadow-md border-l-4 border-maroon">
                            <h3 class="text-xl font-semibold text-maroon mb-2">Total Members</h3>
                            <p class="text-3xl font-bold text-gray-800" id="admin-total-members">0</p>
                        </div>
                        <div class="bg-gray-100 p-4 rounded-lg shadow-md border-l-4 border-maroon">
                            <h3 class="text-xl font-semibold text-maroon mb-2">Total Group Savings</h3>
                            <p class="text-3xl font-bold text-gray-800" id="admin-total-savings">KSh 0.00</p>
                        </div>
                        <div class="bg-gray-100 p-4 rounded-lg shadow-md border-l-4 border-maroon">
                            <h3 class="text-xl font-semibold text-maroon mb-2">Total Loans Issued</h3>
                            <p class="text-3xl font-bold text-gray-800" id="admin-total-loans">KSh 0.00</p>
                        </div>
                        <div class="bg-gray-100 p-4 rounded-lg shadow-md border-l-4 border-maroon">
                            <h3 class="text-xl font-semibold text-maroon mb-2">Available Funds</h3>
                            <p class="text-3xl font-bold text-gray-800" id="admin-available-funds">KSh 0.00</p>
                        </div>
                        <div class="bg-gray-100 p-4 rounded-lg shadow-md border-l-4 border-maroon">
                            <h3 class="text-xl font-semibold text-maroon mb-2">Pending Loan Requests</h3>
                            <p class="text-3xl font-bold text-gray-800" id="admin-pending-loans">0</p>
                        </div>
                        <div class="bg-gray-100 p-4 rounded-lg shadow-md border-l-4 border-maroon">
                            <h3 class="text-xl font-semibold text-maroon mb-2">Pending User Approvals</h3>
                            <p class="text-3xl font-bold text-gray-800" id="admin-pending-users">0</p>
                        </div>
                    </div>
                    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                        <div class="chart-container">
                            <h3 class="text-xl font-semibold text-maroon mb-4">Contributions Trend</h3>
                            <canvas id="contributionsChart"></canvas>
                        </div>
                        <div class="chart-container">
                            <h3 class="text-xl font-semibold text-maroon mb-4">Loan Disbursement vs Repayment</h3>
                            <canvas id="loansChart"></canvas>
                        </div>
                    </div>
                `,
                'manage-users': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Members</h2>
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="member-search" class="input-field max-w-sm" placeholder="Search by name or email...">
                        <div class="flex gap-2">
                             <button class="btn-primary text-sm" onclick="openDataModal('Add New Member', 'users')">
                                <i class="fas fa-user-plus mr-2"></i>Add Member
                             </button>
                             <button class="btn-secondary text-sm" id="bulk-approve-users">
                                <i class="fas fa-check-double mr-2"></i>Bulk Approve
                             </button>
                             <button class="btn-danger text-sm" id="bulk-deactivate-users">
                                <i class="fas fa-user-slash mr-2"></i>Bulk Deactivate
                             </button>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="users-table">
                            <thead>
                                <tr>
                                    <th><input type="checkbox" id="select-all-users"></th>
                                    <th class="cursor-pointer" data-sort="name">Name <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th class="cursor-pointer" data-sort="email">Email <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Phone</th>
                                    <th class="cursor-pointer" data-sort="status">Status <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="users-table-info"></p>
                    </div>
                `,
                'manage-contributions': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">All Contributions</h2>
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="contribution-search" class="input-field max-w-sm" placeholder="Search by member or description...">
                        <input type="date" id="contribution-filter-date" class="input-field max-w-xs">
                        <button class="btn-primary text-sm" onclick="openDataModal('Record New Contribution', 'contributions')">
                            <i class="fas fa-plus-circle mr-2"></i>Record Contribution
                        </button>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="all-contributions-table">
                            <thead>
                                <tr>
                                    <th>Member</th>
                                    <th class="cursor-pointer" data-sort="amount">Amount (KSh) <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Method</th>
                                    <th class="cursor-pointer" data-sort="date">Date <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Description</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="all-contributions-table-info"></p>
                    </div>
                `,
                'manage-loans': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Loans</h2>
                     <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="loan-search" class="input-field max-w-sm" placeholder="Search by member or purpose...">
                        <select id="loan-filter-status" class="input-field max-w-xs">
                            <option value="">All Statuses</option>
                            <option value="pending">Pending</option>
                            <option value="approved">Approved</option>
                            <option value="rejected">Rejected</option>
                            <option value="completed">Completed</option>
                        </select>
                        <button class="btn-primary text-sm" onclick="openDataModal('Add New Loan', 'loans')">
                            <i class="fas fa-plus-circle mr-2"></i>Add Loan
                        </button>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="all-loans-table">
                            <thead>
                                <tr>
                                    <th>Member</th>
                                    <th class="cursor-pointer" data-sort="amount">Amount (KSh) <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Interest Rate (%)</th>
                                    <th>Due Date</th>
                                    <th>Repaid (KSh)</th>
                                    <th>Balance (KSh)</th>
                                    <th class="cursor-pointer" data-sort="status">Status <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Purpose</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="all-loans-table-info"></p>
                    </div>
                `,
                'manage-meetings': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Meetings & Notices</h2>
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="meeting-search" class="input-field max-w-sm" placeholder="Search by title or date...">
                        <button class="btn-primary text-sm" onclick="openDataModal('Add New Meeting/Notice', 'meetings')">
                            <i class="fas fa-plus-circle mr-2"></i>Add Meeting/Notice
                        </button>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="admin-meetings-table">
                            <thead>
                                <tr>
                                    <th class="cursor-pointer" data-sort="title">Title <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th class="cursor-pointer" data-sort="date">Date <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Time</th>
                                    <th>Location</th>
                                    <th class="cursor-pointer" data-sort="type">Type <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Description</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="admin-meetings-table-info"></p>
                    </div>
                `,
                'manage-investments': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Investment Opportunities</h2>
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="investment-search" class="input-field max-w-sm" placeholder="Search by title or description...">
                        <select id="investment-filter-status" class="input-field max-w-xs">
                            <option value="">All Statuses</option>
                            <option value="active">Active</option>
                            <option value="completed">Completed</option>
                            <option value="cancelled">Cancelled</option>
                        </select>
                        <button class="btn-primary text-sm" onclick="openDataModal('Add New Investment', 'investments')">
                            <i class="fas fa-plus-circle mr-2"></i>Add Investment
                        </button>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="admin-investments-table">
                            <thead>
                                <tr>
                                    <th class="cursor-pointer" data-sort="title">Title <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th class="cursor-pointer" data-sort="amount">Goal (KSh) <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th class="cursor-pointer" data-sort="pledged">Pledged (KSh) <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Description</th>
                                    <th>Estimated Return</th>
                                    <th class="cursor-pointer" data-sort="status">Status <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="admin-investments-table-info"></p>
                    </div>
                `,
                'manage-polls': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Voting & Polls</h2>
                     <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="poll-search" class="input-field max-w-sm" placeholder="Search by title...">
                        <button class="btn-primary text-sm" onclick="openDataModal('Create New Poll', 'polls')">
                            <i class="fas fa-plus-circle mr-2"></i>Create Poll
                        </button>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="admin-polls-table">
                            <thead>
                                <tr>
                                    <th class="cursor-pointer" data-sort="title">Title <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Options</th>
                                    <th>Total Votes</th>
                                    <th class="cursor-pointer" data-sort="status">Status <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="admin-polls-table-info"></p>
                    </div>
                `,
                'manage-documents': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Group Documents</h2>
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="document-search" class="input-field max-w-sm" placeholder="Search by title or uploader...">
                        <button class="btn-primary text-sm" onclick="openDataModal('Upload New Document', 'documents')">
                            <i class="fas fa-upload mr-2"></i>Upload Document
                        </button>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="admin-documents-table">
                            <thead>
                                <tr>
                                    <th class="cursor-pointer" data-sort="title">Title <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Uploaded By</th>
                                    <th class="cursor-pointer" data-sort="uploadedAt">Upload Date <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="admin-documents-table-info"></p>
                    </div>
                `,
                 'manage-fines': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Fines & Penalties</h2>
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="text" id="fine-search" class="input-field max-w-sm" placeholder="Search by member or reason...">
                        <select id="fine-filter-status" class="input-field max-w-xs">
                            <option value="">All Statuses</option>
                            <option value="unpaid">Unpaid</option>
                            <option value="paid">Paid</option>
                        </select>
                        <div class="flex gap-2">
                            <button class="btn-primary text-sm" onclick="openDataModal('Issue New Fine', 'fines')">
                                <i class="fas fa-plus-circle mr-2"></i>Issue Fine
                            </button>
                             <button class="btn-secondary text-sm" id="bulk-mark-fines-paid">
                                <i class="fas fa-check-double mr-2"></i>Bulk Mark Paid
                            </button>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="all-fines-table">
                            <thead>
                                <tr>
                                    <th><input type="checkbox" id="select-all-fines"></th>
                                    <th>Member</th>
                                    <th class="cursor-pointer" data-sort="amount">Amount (KSh) <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Reason</th>
                                    <th class="cursor-pointer" data-sort="dateIssued">Date Issued <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th class="cursor-pointer" data-sort="status">Status <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="all-fines-table-info"></p>
                    </div>
                `,
                'manage-attendance': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Attendance Register</h2>
                    <div class="flex flex-col md:flex-row justify-between items-center mb-4 gap-4">
                        <input type="date" id="attendance-filter-date" class="input-field max-w-xs">
                        <div class="flex gap-2">
                            <button class="btn-primary text-sm" onclick="openDataModal('Record New Attendance', 'attendance')">
                                <i class="fas fa-plus-circle mr-2"></i>Record Attendance
                            </button>
                            <button class="btn-secondary text-sm" id="export-attendance-csv">
                                <i class="fas fa-file-csv mr-2"></i>Export CSV
                            </button>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="admin-attendance-table">
                            <thead>
                                <tr>
                                    <th class="cursor-pointer" data-sort="date">Date <i class="fas fa-sort text-xs ml-1"></i></th>
                                    <th>Member</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="admin-attendance-table-info"></p>
                    </div>
                `,
                'manage-notifications': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Manage Notifications</h2>
                    <div class="flex justify-end mb-4">
                        <button class="btn-primary text-sm" onclick="openDataModal('Compose New Notification', 'notifications')">
                            <i class="fas fa-paper-plane mr-2"></i>Compose Notification
                        </button>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-md scroll-y">
                        <table class="data-table" id="admin-notifications-table">
                            <thead>
                                <tr>
                                    <th>Subject</th>
                                    <th>Message</th>
                                    <th>Recipients</th>
                                    <th>Date Sent</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <p class="text-sm text-gray-600 mt-4" id="admin-notifications-table-info"></p>
                    </div>
                `,
                'reports': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Reports</h2>
                    <div class="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <p class="text-gray-700">Generate various financial and activity reports for your Chama.</p>
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            <button class="btn-primary" id="report-financial-statements"><i class="fas fa-file-excel mr-2"></i>Financial Statements</button>
                            <button class="btn-primary" id="report-contributions-summary"><i class="fas fa-file-excel mr-2"></i>Contributions Summary</button>
                            <button class="btn-primary" id="report-loan-report"><i class="fas fa-file-excel mr-2"></i>Loan Report</button>
                            <button class="btn-primary" id="report-fines-report"><i class="fas fa-file-excel mr-2"></i>Fines Report</button>
                            <button class="btn-primary" id="report-attendance-report"><i class="fas fa-file-csv mr-2"></i>Attendance Report</button>
                        </div>
                        <p class="text-sm text-gray-600 mt-4">Reports are generated as CSV files. Ensure you have the necessary permissions to access all data.</p>
                    </div>
                `,
                'admin-settings': `
                    <h2 class="text-2xl font-bold text-maroon mb-6 text-center">Admin Settings (Future Feature)</h2>
                    <div class="bg-white p-6 rounded-lg shadow-md">
                        <p class="text-gray-700">This section will contain global settings for the Chama, such as default loan interest rates, contribution schedules, and more.</p>
                        <p class="text-gray-500 mt-4">Feature in development.</p>
                    </div>
                `
            };

            // Render admin subpage content and attach listeners
            function renderAdminSubpage(pageName) {
                // Remove existing Chart instances to prevent duplicates
                if (window.contributionsChartInstance) {
                    window.contributionsChartInstance.destroy();
                    window.contributionsChartInstance = null;
                }
                if (window.loansChartInstance) {
                    window.loansChartInstance.destroy();
                    window.loansChartInstance = null;
                }

                if (adminSubpages[pageName]) {
                    adminAppContent.innerHTML = adminSubpages[pageName];
                    // Update active class in sidebar
                    document.querySelectorAll('.admin-sidebar-item').forEach(item => {
                        item.classList.remove('active');
                        if (item.dataset.page === pageName) {
                            item.classList.add('active');
                        }
                    });
                    // Hide sidebar on mobile after selection
                    if (window.innerWidth < 768) {
                        adminSidebar.classList.remove('open');
                    }
                    attachAdminSubpageListeners(pageName); // Re-attach listeners for dynamic content
                    window.location.hash = '#' + pageName; // Update URL hash

                    // Load data after rendering specific subpage
                    switch (pageName) {
                        case 'admin-dashboard':
                            loadAdminDashboardSummary();
                            break;
                        case 'manage-users':
                            loadAllUsers();
                            break;
                        case 'manage-contributions':
                            loadAllContributions();
                            break;
                        case 'manage-loans':
                            loadAllLoans();
                            break;
                        case 'manage-meetings':
                            loadAdminMeetings();
                            break;
                        case 'manage-investments':
                            loadAdminInvestments();
                            break;
                        case 'manage-polls':
                            loadAdminPolls();
                            break;
                        case 'manage-documents':
                            loadAdminDocuments();
                            break;
                        case 'manage-fines':
                            loadAdminFines();
                            break;
                        case 'manage-attendance':
                            loadAdminAttendance();
                            break;
                        case 'manage-notifications':
                            loadAdminNotifications();
                            break;
                        case 'reports':
                            attachReportListeners();
                            break;
                    }
                } else {
                    adminAppContent.innerHTML = `<p class="text-center text-red-500">Admin sub-page not found or not yet implemented.</p>`;
                }
            }

            // Attach listeners specific to each admin subpage
            function attachAdminSubpageListeners(pageName) {
                // Sidebar Navigation
                document.querySelectorAll('.admin-sidebar-item').forEach(item => {
                    item.addEventListener('click', (event) => {
                        event.preventDefault(); // Prevent default link behavior
                        renderAdminSubpage(item.dataset.page);
                    });
                });

                // Search/Filter for tables
                const searchInputs = {
                    'manage-users': 'member-search',
                    'manage-contributions': 'contribution-search',
                    'manage-loans': 'loan-search',
                    'manage-meetings': 'meeting-search',
                    'manage-investments': 'investment-search',
                    'manage-polls': 'poll-search',
                    'manage-documents': 'document-search',
                    'manage-fines': 'fine-search'
                };
                if (searchInputs[pageName]) {
                    document.getElementById(searchInputs[pageName])?.addEventListener('input', () => {
                        // Debounce search input for performance
                        clearTimeout(window.searchTimeout);
                        window.searchTimeout = setTimeout(() => {
                            switch(pageName) {
                                case 'manage-users': loadAllUsers(); break;
                                case 'manage-contributions': loadAllContributions(); break;
                                case 'manage-loans': loadAllLoans(); break;
                                case 'manage-meetings': loadAdminMeetings(); break;
                                case 'manage-investments': loadAdminInvestments(); break;
                                case 'manage-polls': loadAdminPolls(); break;
                                case 'manage-documents': loadAdminDocuments(); break;
                                case 'manage-fines': loadAdminFines(); break;
                            }
                        }, 300);
                    });
                }
                const filterSelects = {
                    'manage-loans': 'loan-filter-status',
                    'manage-investments': 'investment-filter-status',
                    'manage-fines': 'fine-filter-status',
                    'manage-attendance': 'attendance-filter-date'
                };
                if (filterSelects[pageName]) {
                    const filterElement = document.getElementById(filterSelects[pageName]);
                    if (filterElement) {
                        filterElement.addEventListener('change', () => {
                            switch(pageName) {
                                case 'manage-loans': loadAllLoans(); break;
                                case 'manage-investments': loadAdminInvestments(); break;
                                case 'manage-fines': loadAdminFines(); break;
                                case 'manage-attendance': loadAdminAttendance(); break;
                            }
                        });
                    }
                }
                 const dateFilter = document.getElementById('attendance-filter-date');
                if (dateFilter) {
                    dateFilter.addEventListener('change', loadAdminAttendance);
                }


                // Sortable table headers
                const tables = {
                    'manage-users': 'users-table',
                    'manage-contributions': 'all-contributions-table',
                    'manage-loans': 'all-loans-table',
                    'manage-meetings': 'admin-meetings-table',
                    'manage-investments': 'admin-investments-table',
                    'manage-polls': 'admin-polls-table',
                    'manage-documents': 'admin-documents-table',
                    'manage-fines': 'all-fines-table',
                    'manage-attendance': 'admin-attendance-table',
                    'manage-notifications': 'admin-notifications-table'
                };

                const currentTableId = tables[pageName];
                if (currentTableId) {
                    const table = document.getElementById(currentTableId);
                    if (table) {
                        table.querySelectorAll('th[data-sort]').forEach(header => {
                            header.addEventListener('click', () => {
                                const sortBy = header.dataset.sort;
                                const currentOrder = header.dataset.order === 'asc' ? 'desc' : 'asc';
                                table.querySelectorAll('th[data-sort]').forEach(h => {
                                    h.removeAttribute('data-order');
                                    const icon = h.querySelector('i');
                                    if (icon) icon.className = 'fas fa-sort text-xs ml-1';
                                });
                                header.dataset.order = currentOrder;
                                const icon = header.querySelector('i');
                                if (icon) icon.className = `fas fa-sort-${currentOrder === 'asc' ? 'up' : 'down'} text-xs ml-1`;

                                // Trigger data reload with new sort parameters
                                switch(pageName) {
                                    case 'manage-users': loadAllUsers(sortBy, currentOrder); break;
                                    case 'manage-contributions': loadAllContributions(sortBy, currentOrder); break;
                                    case 'manage-loans': loadAllLoans(sortBy, currentOrder); break;
                                    case 'manage-meetings': loadAdminMeetings(sortBy, currentOrder); break;
                                    case 'manage-investments': loadAdminInvestments(sortBy, currentOrder); break;
                                    case 'manage-polls': loadAdminPolls(sortBy, currentOrder); break;
                                    case 'manage-documents': loadAdminDocuments(sortBy, currentOrder); break;
                                    case 'manage-fines': loadAdminFines(sortBy, currentOrder); break;
                                    case 'manage-attendance': loadAdminAttendance(sortBy, currentOrder); break;
                                    case 'manage-notifications': loadAdminNotifications(sortBy, currentOrder); break;
                                }
                            });
                        });
                    }
                }


                // Checkbox for select all
                const selectAllUsers = document.getElementById('select-all-users');
                if (selectAllUsers) {
                    selectAllUsers.onchange = (e) => {
                        document.querySelectorAll('#users-table tbody input[type="checkbox"]').forEach(checkbox => {
                            checkbox.checked = e.target.checked;
                        });
                    };
                }
                const selectAllFines = document.getElementById('select-all-fines');
                if (selectAllFines) {
                    selectAllFines.onchange = (e) => {
                        document.querySelectorAll('#all-fines-table tbody input[type="checkbox"]').forEach(checkbox => {
                            checkbox.checked = e.target.checked;
                        });
                    };
                }

                // Bulk Actions
                document.getElementById('bulk-approve-users')?.addEventListener('click', handleBulkApproveUsers);
                document.getElementById('bulk-deactivate-users')?.addEventListener('click', handleBulkDeactivateUsers);
                document.getElementById('bulk-mark-fines-paid')?.addEventListener('click', handleBulkMarkFinesPaid);


                // Report buttons
                if (pageName === 'reports') {
                    attachReportListeners();
                }
            }


            // --- Admin Data Loading Functions ---

            async function loadAdminDashboardSummary() {
                const totalMembersEl = document.getElementById('admin-total-members');
                const totalSavingsEl = document.getElementById('admin-total-savings');
                const totalLoansEl = document.getElementById('admin-total-loans');
                const fundsAvailableEl = document.getElementById('admin-available-funds');
                const pendingLoansEl = document.getElementById('admin-pending-loans');
                const pendingUsersEl = document.getElementById('admin-pending-users');
                const contributionsChartCanvas = document.getElementById('contributionsChart');
                const loansChartCanvas = document.getElementById('loansChart');

                if (!totalMembersEl || !totalSavingsEl || !totalLoansEl || !fundsAvailableEl || !pendingLoansEl || !pendingUsersEl || !contributionsChartCanvas || !loansChartCanvas) return;

                let totalContributions = 0;
                let totalLoansIssued = 0;
                let pendingLoanCount = 0;
                let pendingUserCount = 0;
                let totalMembers = 0;

                const contributionsData = {}; // For contributions trend chart
                const loanDisbursement = {}; // For loan chart
                const loanRepayment = {}; // For loan chart

                try {
                    const usersCollectionGroup = collectionGroup(db, 'user_profile');
                    const allUsersSnapshot = await getDocs(usersCollectionGroup);
                    totalMembers = allUsersSnapshot.size;

                    for (const userDoc of allUsersSnapshot.docs) {
                        const userData = userDoc.data();
                        const userId = userDoc.id;

                        totalContributions += userData.contribution_balance || 0;
                        totalLoansIssued += userData.loan_balance || 0; // Tracks outstanding loan balance
                        if (userData.status === 'pending') {
                            pendingUserCount++;
                        }

                        // Aggregate contributions for chart
                        const contributionsSnapshot = await getDocs(query(collection(db, getPrivateCollectionPath(userId, 'contributions')), orderBy('date')));
                        contributionsSnapshot.forEach(doc => {
                            const date = doc.data().date ? new Date(doc.data().date.seconds * 1000) : null;
                            if (date) {
                                const monthYear = date.toLocaleString('en-US', { month: 'short', year: 'numeric' });
                                contributionsData[monthYear] = (contributionsData[monthYear] || 0) + doc.data().amount;
                            }
                        });

                        // Aggregate loan data for chart
                        const loansSnapshot = await getDocs(query(collection(db, getPrivateCollectionPath(userId, 'loans')), orderBy('timestamp')));
                        loansSnapshot.forEach(doc => {
                            const data = doc.data();
                            const loanDate = data.timestamp ? new Date(data.timestamp.seconds * 1000) : null;
                            if (loanDate) {
                                const monthYear = loanDate.toLocaleString('en-US', { month: 'short', year: 'numeric' });
                                loanDisbursement[monthYear] = (loanDisbursement[monthYear] || 0) + data.amount;
                                loanRepayment[monthYear] = (loanRepayment[monthYear] || 0) + (data.repaidAmount || 0);
                            }
                            if (data.status === 'pending') {
                                pendingLoanCount++;
                            }
                        });
                    }

                    const fundsAvailable = totalContributions - totalLoansIssued; // Simplified, assuming loans are taken from contributions

                    totalMembersEl.textContent = totalMembers;
                    totalSavingsEl.textContent = `KSh ${totalContributions.toFixed(2)}`;
                    totalLoansEl.textContent = `KSh ${totalLoansIssued.toFixed(2)}`;
                    fundsAvailableEl.textContent = `KSh ${fundsAvailable.toFixed(2)}`;
                    pendingLoansEl.textContent = pendingLoanCount;
                    pendingUsersEl.textContent = pendingUserCount;

                    console.log("Admin Dashboard Summary Loaded.");

                    renderContributionsChart(contributionsChartCanvas, contributionsData);
                    renderLoansChart(loansChartCanvas, loanDisbursement, loanRepayment);

                } catch (error) {
                    console.error("Error loading admin dashboard summary:", error);
                    showMessage("Failed to load dashboard summary data.", "error");
                    // Set default placeholders on error
                    totalMembersEl.textContent = "0";
                    totalSavingsEl.textContent = "KSh 0.00";
                    totalLoansEl.textContent = "KSh 0.00";
                    fundsAvailableEl.textContent = "KSh 0.00";
                    pendingLoansEl.textContent = "0";
                    pendingUsersEl.textContent = "0";
                }
            }

            // Chart Rendering Functions
            function renderContributionsChart(canvas, data) {
                const labels = Object.keys(data).sort((a, b) => new Date(a) - new Date(b));
                const values = labels.map(label => data[label]);

                if (window.contributionsChartInstance) {
                    window.contributionsChartInstance.destroy();
                }
                window.contributionsChartInstance = new Chart(canvas, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Total Contributions (KSh)',
                            data: values,
                            borderColor: var_primary_maroon,
                            backgroundColor: 'rgba(128, 0, 0, 0.2)',
                            fill: true,
                            tension: 0.3
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: { beginAtZero: true }
                        }
                    }
                });
            }

            function renderLoansChart(canvas, disbursementData, repaymentData) {
                const allLabels = new Set([...Object.keys(disbursementData), ...Object.keys(repaymentData)]);
                const labels = Array.from(allLabels).sort((a, b) => new Date(a) - new Date(b));
                const disbursementValues = labels.map(label => disbursementData[label] || 0);
                const repaymentValues = labels.map(label => repaymentData[label] || 0);

                if (window.loansChartInstance) {
                    window.loansChartInstance.destroy();
                }
                window.loansChartInstance = new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Loans Disbursed (KSh)',
                                data: disbursementValues,
                                backgroundColor: var_primary_maroon,
                            },
                            {
                                label: 'Loans Repaid (KSh)',
                                data: repaymentValues,
                                backgroundColor: '#4CAF50', // Green
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: false },
                            y: { beginAtZero: true, stacked: false }
                        }
                    }
                });
            }

            // Helper to convert CSS variable to JS
            const getCssVariable = (name) => getComputedStyle(document.documentElement).getPropertyValue(name).trim();
            const var_primary_maroon = getCssVariable('--primary-maroon');


            async function loadAllUsers(sortBy = 'createdAt', sortOrder = 'desc') {
                const tableBody = document.querySelector('#users-table tbody');
                const infoText = document.getElementById('users-table-info');
                const searchInput = document.getElementById('member-search');
                if (!tableBody || !infoText || !searchInput) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading users...";
                unsubscribeAllListeners(); // Unsubscribe previous listener for this table

                let q = query(collectionGroup(db, 'user_profile'), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();
                if (searchTerm) {
                    // For client-side search, we fetch all and filter locally
                    // A proper backend search (Cloud Function or Algolia) would be needed for large datasets
                }

                // Attach listener
                const unsub = onSnapshot(q, (snapshot) => {
                    const users = [];
                    snapshot.forEach((doc) => {
                        const user = { id: doc.id, ...doc.data() };
                        if (searchTerm === '' ||
                            (user.name && user.name.toLowerCase().includes(searchTerm)) ||
                            (user.email && user.email.toLowerCase().includes(searchTerm))) {
                            users.push(user);
                        }
                    });

                    tableBody.innerHTML = '';
                    if (users.length === 0) {
                        infoText.textContent = `No users found matching your criteria. Possible causes: 
                          1. No data exists or no match.
                          2. Firestore rules are blocking access (check browser console).
                          3. Missing a Collection Group index for 'user_profile' (check Firebase console for link).`;
                        tableBody.innerHTML = `<tr><td colspan="6" class="text-center text-gray-500">No users found.</td></tr>`;
                        console.warn("No user profiles found via collectionGroup query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${users.length} user(s).`;
                    users.forEach((user) => {
                        const row = `
                            <tr>
                                <td><input type="checkbox" data-user-id="${user.id}"></td>
                                <td>${user.name || 'N/A'}</td>
                                <td>${user.email || 'N/A'}</td>
                                <td>${user.phone || 'N/A'}</td>
                                <td>${user.status || 'N/A'}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-primary px-3 py-1 text-sm" onclick="openDataModal('Edit Member', 'users', ${JSON.stringify(user).replace(/"/g, '&quot;')})"><i class="fas fa-edit"></i> Edit</button>
                                    ${user.status !== 'approved' ? `<button class="btn-primary px-3 py-1 text-sm approve-user-btn" data-user-id="${user.id}"><i class="fas fa-check"></i> Approve</button>` : ''}
                                    ${user.status !== 'deactivated' ? `<button class="btn-secondary px-3 py-1 text-sm deactivate-user-btn" data-user-id="${user.id}"><i class="fas fa-user-slash"></i> Deactivate</button>` : ''}
                                    <button class="btn-danger px-3 py-1 text-sm delete-user-btn" data-user-id="${user.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${users.length} user profiles.`);
                }, (error) => {
                    console.error("Firestore listener error for all users:", error);
                    showMessage("Failed to load users due to an error.", "error");
                    infoText.textContent = "Error loading users. Check console for details.";
                });
                unsubscribeListeners.push(unsub);
            }

            async function loadAllContributions(sortBy = 'date', sortOrder = 'desc') {
                const tableBody = document.querySelector('#all-contributions-table tbody');
                const infoText = document.getElementById('all-contributions-table-info');
                const searchInput = document.getElementById('contribution-search');
                const filterDateInput = document.getElementById('contribution-filter-date');
                if (!tableBody || !infoText || !searchInput || !filterDateInput) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading contributions...";
                unsubscribeAllListeners();

                let q = query(collectionGroup(db, 'contributions'), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();
                const filterDate = filterDateInput.value;

                const unsub = onSnapshot(q, async (snapshot) => {
                    let contributions = [];
                    for (const docSnapshot of snapshot.docs) {
                        const data = docSnapshot.data();
                        const memberId = data.memberId;
                        let memberName = `Unknown User (${memberId})`;
                        // Fetch member name, but do it outside the main loop if possible for performance
                        // For now, doing it here for simplicity, but for huge datasets, pre-fetching is better.
                        try {
                            const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                            if (profileDoc.exists()) {
                                memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                            }
                        } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }

                        const contributionDate = data.date ? new Date(data.date.seconds * 1000) : null;
                        const dateString = contributionDate ? contributionDate.toISOString().split('T')[0] : 'N/A';

                        // Apply filters
                        const matchesSearch = (memberName.toLowerCase().includes(searchTerm) || (data.description && data.description.toLowerCase().includes(searchTerm)));
                        const matchesDate = !filterDate || (dateString === filterDate);

                        if (matchesSearch && matchesDate) {
                            contributions.push({
                                id: docSnapshot.id,
                                memberId: memberId,
                                memberName: memberName,
                                amount: data.amount,
                                method: data.method,
                                date: contributionDate, // Keep as Date object for sorting if needed later
                                dateString: contributionDate ? contributionDate.toLocaleDateString() : 'N/A',
                                description: data.description || 'N/A'
                            });
                        }
                    }

                    // Client-side sort if sortBy is not a direct Firestore field
                    if (sortBy === 'memberName') {
                        contributions.sort((a, b) => {
                            const valA = a.memberName.toLowerCase();
                            const valB = b.memberName.toLowerCase();
                            return sortOrder === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                        });
                    }

                    tableBody.innerHTML = '';
                    if (contributions.length === 0) {
                        infoText.textContent = `No contributions found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.
                          3. Missing a Collection Group index for 'contributions'.`;
                        tableBody.innerHTML = `<tr><td colspan="6" class="text-center text-gray-500">No contributions found.</td></tr>`;
                        console.warn("No contributions found via collectionGroup query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${contributions.length} contribution(s).`;
                    contributions.forEach(contrib => {
                        const row = `
                            <tr>
                                <td>${contrib.memberName}</td>
                                <td>${contrib.amount.toFixed(2)}</td>
                                <td>${contrib.method}</td>
                                <td>${contrib.dateString}</td>
                                <td>${contrib.description}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-primary px-3 py-1 text-sm" onclick="openDataModal('Edit Contribution', 'contributions', ${JSON.stringify(contrib).replace(/"/g, '&quot;')})"><i class="fas fa-edit"></i> Edit</button>
                                    <button class="btn-danger px-3 py-1 text-sm delete-contribution-btn" data-member-id="${contrib.memberId}" data-id="${contrib.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${contributions.length} contributions.`);
                }, (error) => {
                    console.error("Firestore listener error for all contributions:", error);
                    showMessage("Failed to load contributions due to an error.", "error");
                    infoText.textContent = "Error loading contributions. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                 // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-contribution-btn')) {
                        const memberId = target.dataset.memberId;
                        const contribId = target.dataset.id;
                        const confirmed = await showCustomConfirm("Delete Contribution", "Are you sure you want to delete this contribution?");
                        if (confirmed) {
                            await handleDeleteContribution(memberId, contribId);
                        }
                    }
                });
            }

            async function loadAllLoans(sortBy = 'timestamp', sortOrder = 'desc') {
                const tableBody = document.querySelector('#all-loans-table tbody');
                const infoText = document.getElementById('all-loans-table-info');
                const searchInput = document.getElementById('loan-search');
                const filterStatusSelect = document.getElementById('loan-filter-status');
                if (!tableBody || !infoText || !searchInput || !filterStatusSelect) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading loans...";
                unsubscribeAllListeners();

                let q = query(collectionGroup(db, 'loans'), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();
                const filterStatus = filterStatusSelect.value;

                const unsub = onSnapshot(q, async (snapshot) => {
                    let loans = [];
                    for (const docSnapshot of snapshot.docs) {
                        const data = docSnapshot.data();
                        const memberId = data.memberId;
                        let memberName = `Unknown User (${memberId})`;
                        try {
                            const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                            if (profileDoc.exists()) {
                                memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                            }
                        } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }

                        // Apply filters
                        const matchesSearch = (memberName.toLowerCase().includes(searchTerm) || (data.purpose && data.purpose.toLowerCase().includes(searchTerm)));
                        const matchesStatus = !filterStatus || (data.status === filterStatus);

                        if (matchesSearch && matchesStatus) {
                            loans.push({
                                id: docSnapshot.id,
                                memberId: memberId,
                                memberName: memberName,
                                amount: data.amount,
                                interestRate: data.interestRate,
                                dueDate: data.dueDate,
                                dueDateString: data.dueDate ? new Date(data.dueDate.seconds * 1000).toLocaleDateString() : 'N/A',
                                repaidAmount: data.repaidAmount || 0,
                                status: data.status,
                                purpose: data.purpose
                            });
                        }
                    }

                    tableBody.innerHTML = '';
                    if (loans.length === 0) {
                        infoText.textContent = `No loan requests found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.
                          3. Missing a Collection Group index for 'loans'.`;
                        tableBody.innerHTML = `<tr><td colspan="9" class="text-center text-gray-500">No loan requests found.</td></tr>`;
                        console.warn("No loan requests found via collectionGroup query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${loans.length} loan(s).`;
                    loans.forEach(loan => {
                        const balance = (loan.amount - loan.repaidAmount).toFixed(2);
                        const row = `
                            <tr>
                                <td>${loan.memberName}</td>
                                <td>${loan.amount.toFixed(2)}</td>
                                <td>${loan.interestRate.toFixed(1)}</td>
                                <td>${loan.dueDateString}</td>
                                <td>${loan.repaidAmount.toFixed(2)}</td>
                                <td>${balance}</td>
                                <td>${loan.status}</td>
                                <td>${loan.purpose}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-primary px-3 py-1 text-sm" onclick="openDataModal('Edit Loan', 'loans', ${JSON.stringify(loan).replace(/"/g, '&quot;')})"><i class="fas fa-edit"></i> Edit</button>
                                    ${loan.status === 'pending' ? `<button class="btn-primary px-3 py-1 text-sm approve-loan-btn" data-member-id="${loan.memberId}" data-loan-id="${loan.id}"><i class="fas fa-check"></i> Approve</button>` : ''}
                                    ${loan.status === 'pending' ? `<button class="btn-danger px-3 py-1 text-sm reject-loan-btn" data-member-id="${loan.memberId}" data-loan-id="${loan.id}"><i class="fas fa-times"></i> Reject</button>` : ''}
                                    ${loan.status === 'approved' && parseFloat(balance) > 0 ? `<button class="btn-secondary px-3 py-1 text-sm record-repayment-btn" data-member-id="${loan.memberId}" data-loan-id="${loan.id}"><i class="fas fa-money-bill-wave"></i> Repay</button>` : ''}
                                    <button class="btn-danger px-3 py-1 text-sm delete-loan-btn" data-member-id="${loan.memberId}" data-loan-id="${loan.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${loans.length} loans.`);
                }, (error) => {
                    console.error("Firestore listener error for all loans:", error);
                    showMessage("Failed to load loans due to an error.", "error");
                    infoText.textContent = "Error loading loans. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('approve-loan-btn')) {
                        const memberId = target.dataset.memberId;
                        const loanId = target.dataset.loanId;
                        await handleApproveLoan(memberId, loanId);
                    } else if (target.classList.contains('reject-loan-btn')) {
                        const memberId = target.dataset.memberId;
                        const loanId = target.dataset.loanId;
                        const confirmed = await showCustomConfirm("Reject Loan", "Are you sure you want to reject this loan request?");
                        if (confirmed) {
                            await handleRejectLoan(memberId, loanId);
                        }
                    } else if (target.classList.contains('record-repayment-btn')) {
                        const memberId = target.dataset.memberId;
                        const loanId = target.dataset.loanId;
                        const amountStr = prompt("Enter repayment amount:");
                        const amountRepaid = parseFloat(amountStr);
                        if (!isNaN(amountRepaid) && amountRepaid > 0) {
                            await handleRecordLoanRepayment(memberId, loanId, amountRepaid);
                        } else if (amountStr !== null) {
                            showMessage("Invalid repayment amount.", "error");
                        }
                    } else if (target.classList.contains('delete-loan-btn')) {
                        const memberId = target.dataset.memberId;
                        const loanId = target.dataset.loanId;
                        const confirmed = await showCustomConfirm("Delete Loan", "Are you sure you want to delete this loan record?");
                        if (confirmed) {
                            await handleDeleteLoan(memberId, loanId);
                        }
                    }
                });
            }


            function loadAdminMeetings(sortBy = 'date', sortOrder = 'asc') {
                const tableBody = document.querySelector('#admin-meetings-table tbody');
                const infoText = document.getElementById('admin-meetings-table-info');
                const searchInput = document.getElementById('meeting-search');
                if (!tableBody || !infoText || !searchInput) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading meetings...";
                unsubscribeAllListeners();

                let q = query(collection(db, getPublicCollectionPath('meetings')), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();

                const unsub = onSnapshot(q, (snapshot) => {
                    let meetings = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const meetingDate = data.date ? new Date(data.date.seconds * 1000) : null;
                        const dateString = meetingDate ? meetingDate.toLocaleDateString() : 'N/A';
                        const meetsSearch = (data.title && data.title.toLowerCase().includes(searchTerm)) || (dateString.toLowerCase().includes(searchTerm));

                        if (meetsSearch) {
                             meetings.push({
                                id: doc.id,
                                title: data.title,
                                date: meetingDate,
                                dateString: meetingDate ? meetingDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' }) : 'N/A',
                                time: data.time || 'N/A',
                                location: data.location || 'N/A',
                                description: data.description || 'N/A',
                                type: data.type || 'N/A'
                            });
                        }
                    });

                    tableBody.innerHTML = '';
                    if (meetings.length === 0) {
                        infoText.textContent = `No meetings/notices found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.`;
                        tableBody.innerHTML = `<tr><td colspan="7" class="text-center text-gray-500">No meetings/notices found.</td></tr>`;
                        console.warn("No meetings found via public collection query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${meetings.length} meeting(s)/notice(s).`;
                    meetings.forEach(meeting => {
                        const row = `
                            <tr>
                                <td>${meeting.title}</td>
                                <td>${meeting.dateString}</td>
                                <td>${meeting.time}</td>
                                <td>${meeting.location}</td>
                                <td>${meeting.type}</td>
                                <td>${meeting.description}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-primary px-3 py-1 text-sm" onclick="openDataModal('Edit Meeting/Notice', 'meetings', ${JSON.stringify(meeting).replace(/"/g, '&quot;')})"><i class="fas fa-edit"></i> Edit</button>
                                    <button class="btn-danger px-3 py-1 text-sm delete-meeting-btn" data-id="${meeting.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${meetings.length} meetings.`);
                }, (error) => {
                    console.error("Firestore listener error for admin meetings:", error);
                    showMessage("Failed to load meetings.", "error");
                    infoText.textContent = "Error loading meetings. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-meeting-btn')) {
                        const meetingId = target.dataset.id;
                        const confirmed = await showCustomConfirm("Delete Meeting", "Are you sure you want to delete this meeting?");
                        if (confirmed) {
                            await handleDeletePublicData('meetings', meetingId);
                        }
                    }
                });
            }

            function loadAdminInvestments(sortBy = 'createdAt', sortOrder = 'desc') {
                const tableBody = document.querySelector('#admin-investments-table tbody');
                const infoText = document.getElementById('admin-investments-table-info');
                const searchInput = document.getElementById('investment-search');
                const filterStatusSelect = document.getElementById('investment-filter-status');
                if (!tableBody || !infoText || !searchInput || !filterStatusSelect) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading investments...";
                unsubscribeAllListeners();

                let q = query(collection(db, getPublicCollectionPath('investments')), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();
                const filterStatus = filterStatusSelect.value;

                const unsub = onSnapshot(q, (snapshot) => {
                    let investments = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const matchesSearch = (data.title && data.title.toLowerCase().includes(searchTerm)) || (data.description && data.description.toLowerCase().includes(searchTerm));
                        const matchesStatus = !filterStatus || (data.status === filterStatus);

                        if (matchesSearch && matchesStatus) {
                            investments.push({
                                id: doc.id,
                                title: data.title,
                                amount: data.amount,
                                pledged: data.pledged || 0,
                                description: data.description,
                                estimatedReturn: data.estimatedReturn,
                                status: data.status
                            });
                        }
                    });

                    tableBody.innerHTML = '';
                    if (investments.length === 0) {
                        infoText.textContent = `No investment opportunities found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.`;
                        tableBody.innerHTML = `<tr><td colspan="7" class="text-center text-gray-500">No investment opportunities found.</td></tr>`;
                        console.warn("No investments found via public collection query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${investments.length} investment(s).`;
                    investments.forEach(inv => {
                        const row = `
                            <tr>
                                <td>${inv.title}</td>
                                <td>${inv.amount.toFixed(2)}</td>
                                <td>${inv.pledged.toFixed(2)}</td>
                                <td>${inv.description}</td>
                                <td>${inv.estimatedReturn}</td>
                                <td>${inv.status}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-primary px-3 py-1 text-sm" onclick="openDataModal('Edit Investment', 'investments', ${JSON.stringify(inv).replace(/"/g, '&quot;')})"><i class="fas fa-edit"></i> Edit</button>
                                    ${inv.status !== 'completed' ? `<button class="btn-secondary px-3 py-1 text-sm mark-completed-investment-btn" data-id="${inv.id}"><i class="fas fa-check"></i> Mark Completed</button>` : ''}
                                    <button class="btn-danger px-3 py-1 text-sm delete-investment-btn" data-id="${inv.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${investments.length} investments.`);
                }, (error) => {
                    console.error("Firestore listener error for admin investments:", error);
                    showMessage("Failed to load investments.", "error");
                    infoText.textContent = "Error loading investments. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-investment-btn')) {
                        const investmentId = target.dataset.id;
                        const confirmed = await showCustomConfirm("Delete Investment", "Are you sure you want to delete this investment?");
                        if (confirmed) {
                            await handleDeletePublicData('investments', investmentId);
                        }
                    } else if (target.classList.contains('mark-completed-investment-btn')) {
                        const investmentId = target.dataset.id;
                        await handleMarkInvestmentCompleted(investmentId);
                    }
                });
            }

            function loadAdminPolls(sortBy = 'createdAt', sortOrder = 'desc') {
                const tableBody = document.querySelector('#admin-polls-table tbody');
                const infoText = document.getElementById('admin-polls-table-info');
                const searchInput = document.getElementById('poll-search');
                if (!tableBody || !infoText || !searchInput) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading polls...";
                unsubscribeAllListeners();

                let q = query(collection(db, getPublicCollectionPath('polls')), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();

                const unsub = onSnapshot(q, (snapshot) => {
                    let polls = [];
                    snapshot.forEach(doc => {
                        const poll = { id: doc.id, ...doc.data() };
                        const matchesSearch = (poll.title && poll.title.toLowerCase().includes(searchTerm)) || (poll.description && poll.description.toLowerCase().includes(searchTerm));

                        if (matchesSearch) {
                            polls.push(poll);
                        }
                    });

                    tableBody.innerHTML = '';
                    if (polls.length === 0) {
                        infoText.textContent = `No polls found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.`;
                        tableBody.innerHTML = `<tr><td colspan="5" class="text-center text-gray-500">No polls found.</td></tr>`;
                        console.warn("No polls found via public collection query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${polls.length} poll(s).`;
                    polls.forEach(poll => {
                        const totalVotes = Object.values(poll.votes || {}).reduce((sum, count) => sum + count, 0);
                        const optionsDisplay = Array.isArray(poll.options) ? poll.options.join(', ') : 'N/A';
                        const row = `
                            <tr>
                                <td>${poll.title}</td>
                                <td>${optionsDisplay}</td>
                                <td>${totalVotes}</td>
                                <td>${poll.status}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-primary px-3 py-1 text-sm" onclick="openDataModal('Edit Poll', 'polls', ${JSON.stringify(poll).replace(/"/g, '&quot;')})"><i class="fas fa-edit"></i> Edit</button>
                                    <button class="btn-secondary px-3 py-1 text-sm view-results-poll-btn" data-id="${poll.id}" data-poll-data="${JSON.stringify(poll).replace(/"/g, '&quot;')}" ><i class="fas fa-chart-bar"></i> Results</button>
                                    ${poll.status !== 'closed' ? `<button class="btn-secondary px-3 py-1 text-sm close-poll-btn" data-id="${poll.id}"><i class="fas fa-lock"></i> Close</button>` : ''}
                                    <button class="btn-danger px-3 py-1 text-sm delete-poll-btn" data-id="${poll.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${polls.length} polls.`);
                }, (error) => {
                    console.error("Firestore listener error for admin polls:", error);
                    showMessage("Failed to load polls.", "error");
                    infoText.textContent = "Error loading polls. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-poll-btn')) {
                        const pollId = target.dataset.id;
                        const confirmed = await showCustomConfirm("Delete Poll", "Are you sure you want to delete this poll?");
                        if (confirmed) {
                            await handleDeletePublicData('polls', pollId);
                        }
                    } else if (target.classList.contains('close-poll-btn')) {
                        const pollId = target.dataset.id;
                        await handleClosePoll(pollId);
                    } else if (target.classList.contains('view-results-poll-btn')) {
                        const pollData = JSON.parse(target.dataset.pollData);
                        displayPollResultsChart(pollData);
                    }
                });
            }

            function loadAdminDocuments(sortBy = 'uploadedAt', sortOrder = 'desc') {
                const tableBody = document.querySelector('#admin-documents-table tbody');
                const infoText = document.getElementById('admin-documents-table-info');
                const searchInput = document.getElementById('document-search');
                if (!tableBody || !infoText || !searchInput) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading documents...";
                unsubscribeAllListeners();

                let q = query(collection(db, getPublicCollectionPath('documents')), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();

                const unsub = onSnapshot(q, (snapshot) => {
                    let documents = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        const matchesSearch = (data.title && data.title.toLowerCase().includes(searchTerm)) || (data.uploadedBy && data.uploadedBy.toLowerCase().includes(searchTerm));

                        if (matchesSearch) {
                            documents.push({ id: doc.id, ...data });
                        }
                    });

                    tableBody.innerHTML = '';
                    if (documents.length === 0) {
                        infoText.textContent = `No documents found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.`;
                        tableBody.innerHTML = `<tr><td colspan="4" class="text-center text-gray-500">No documents found.</td></tr>`;
                        console.warn("No documents found via public collection query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${documents.length} document(s).`;
                    documents.forEach(docData => {
                        const uploadedAtDate = docData.uploadedAt ? new Date(docData.uploadedAt.seconds * 1000).toLocaleDateString() : 'N/A';
                        const row = `
                            <tr>
                                <td>${docData.title}</td>
                                <td>${docData.uploadedBy || 'N/A'}</td>
                                <td>${uploadedAtDate}</td>
                                <td class="actions space-x-2">
                                    <a href="${docData.fileUrl}" target="_blank" class="btn-primary px-3 py-1 text-sm"><i class="fas fa-download"></i> Download</a>
                                    <button class="btn-danger px-3 py-1 text-sm delete-document-btn" data-id="${docData.id}" data-file-url="${docData.fileUrl || ''}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${documents.length} documents.`);
                }, (error) => {
                    console.error("Firestore listener error for admin documents:", error);
                    showMessage("Failed to load documents.", "error");
                    infoText.textContent = "Error loading documents. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                 // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-document-btn')) {
                        const docId = target.dataset.id;
                        const fileUrl = target.dataset.fileUrl; // Get the file URL to delete from storage
                        const confirmed = await showCustomConfirm("Delete Document", "Are you sure you want to delete this document? This will also delete the file from storage.");
                        if (confirmed) {
                            await handleDeletePublicData('documents', docId);
                            // Also try to delete from Firebase Storage if URL is present
                            if (fileUrl && fileUrl.startsWith('gs://')) { // Check if it's a Firebase Storage URL
                                try {
                                    const storageRef = ref(storage, fileUrl);
                                    await deleteObject(storageRef);
                                    showMessage("File also deleted from storage.", "success");
                                } catch (storageError) {
                                    console.warn("Could not delete file from Firebase Storage (might not be a storage URL or permissions issue):", storageError);
                                    showMessage("Document record deleted, but failed to delete file from storage. Check console.", "error");
                                }
                            }
                        }
                    }
                });
            }

            async function loadAdminFines(sortBy = 'dateIssued', sortOrder = 'desc') {
                const tableBody = document.querySelector('#all-fines-table tbody');
                const infoText = document.getElementById('all-fines-table-info');
                const searchInput = document.getElementById('fine-search');
                const filterStatusSelect = document.getElementById('fine-filter-status');
                if (!tableBody || !infoText || !searchInput || !filterStatusSelect) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading fines...";
                unsubscribeAllListeners();

                let q = query(collectionGroup(db, 'fines'), orderBy(sortBy, sortOrder));

                const searchTerm = searchInput.value.toLowerCase();
                const filterStatus = filterStatusSelect.value;

                const unsub = onSnapshot(q, async (snapshot) => {
                    let fines = [];
                    for (const docSnapshot of snapshot.docs) {
                        const data = docSnapshot.data();
                        const memberId = data.memberId;
                        let memberName = `Unknown User (${memberId})`;
                        try {
                            const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                            if (profileDoc.exists()) {
                                memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                            }
                        } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }

                        // Apply filters
                        const matchesSearch = (memberName.toLowerCase().includes(searchTerm) || (data.reason && data.reason.toLowerCase().includes(searchTerm)));
                        const matchesStatus = !filterStatus || (data.status === filterStatus);

                        if (matchesSearch && matchesStatus) {
                            fines.push({
                                id: docSnapshot.id,
                                memberId: memberId,
                                memberName: memberName,
                                amount: data.amount,
                                reason: data.reason,
                                dateIssued: data.dateIssued,
                                dateIssuedString: data.dateIssued ? new Date(data.dateIssued.seconds * 1000).toLocaleDateString() : 'N/A',
                                status: data.status
                            });
                        }
                    }

                    tableBody.innerHTML = '';
                    if (fines.length === 0) {
                        infoText.textContent = `No fines found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.
                          3. Missing a Collection Group index for 'fines'.`;
                        tableBody.innerHTML = `<tr><td colspan="7" class="text-center text-gray-500">No fines found.</td></tr>`;
                        console.warn("No fines found via collectionGroup query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${fines.length} fine(s).`;
                    fines.forEach(fine => {
                        const row = `
                            <tr>
                                <td><input type="checkbox" data-fine-id="${fine.id}" data-member-id="${fine.memberId}" ${fine.status === 'paid' ? 'disabled' : ''}></td>
                                <td>${fine.memberName}</td>
                                <td>${fine.amount.toFixed(2)}</td>
                                <td>${fine.reason}</td>
                                <td>${fine.dateIssuedString}</td>
                                <td>${fine.status}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-primary px-3 py-1 text-sm" onclick="openDataModal('Edit Fine', 'fines', ${JSON.stringify(fine).replace(/"/g, '&quot;')})"><i class="fas fa-edit"></i> Edit</button>
                                    ${fine.status === 'unpaid' ? `<button class="btn-secondary px-3 py-1 text-sm mark-paid-fine-btn" data-member-id="${fine.memberId}" data-fine-id="${fine.id}"><i class="fas fa-check"></i> Mark Paid</button>` : ''}
                                    <button class="btn-danger px-3 py-1 text-sm delete-fine-btn" data-member-id="${fine.memberId}" data-fine-id="${fine.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${fines.length} fines.`);
                }, (error) => {
                    console.error("Firestore listener error for all fines:", error);
                    showMessage("Failed to load fines due to an error.", "error");
                    infoText.textContent = "Error loading fines. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-fine-btn')) {
                        const memberId = target.dataset.memberId;
                        const fineId = target.dataset.fineId;
                        const confirmed = await showCustomConfirm("Delete Fine", "Are you sure you want to delete this fine?");
                        if (confirmed) {
                            await handleDeleteFine(memberId, fineId);
                        }
                    } else if (target.classList.contains('mark-paid-fine-btn')) {
                        const memberId = target.dataset.memberId;
                        const fineId = target.dataset.fineId;
                        await handleMarkFinePaid(memberId, fineId);
                    }
                });
            }

            async function loadAdminAttendance(sortBy = 'date', sortOrder = 'desc') {
                const tableBody = document.querySelector('#admin-attendance-table tbody');
                const infoText = document.getElementById('admin-attendance-table-info');
                const filterDateInput = document.getElementById('attendance-filter-date');
                if (!tableBody || !infoText || !filterDateInput) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading attendance records...";
                unsubscribeAllListeners();

                let q = query(collectionGroup(db, 'attendance'), orderBy(sortBy, sortOrder));

                const filterDate = filterDateInput.value;

                const unsub = onSnapshot(q, async (snapshot) => {
                    let attendanceRecords = [];
                    for (const docSnapshot of snapshot.docs) {
                        const data = docSnapshot.data();
                        const memberId = data.memberId;
                        let memberName = `Unknown User (${memberId})`;
                        try {
                            const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                            if (profileDoc.exists()) {
                                memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                            }
                        } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }

                        const attendanceDate = data.date ? new Date(data.date.seconds * 1000) : null;
                        const dateString = attendanceDate ? attendanceDate.toISOString().split('T')[0] : 'N/A';

                        const matchesDate = !filterDate || (dateString === filterDate);

                        if (matchesDate) {
                            attendanceRecords.push({
                                id: docSnapshot.id,
                                memberId: memberId,
                                memberName: memberName,
                                date: attendanceDate,
                                dateString: attendanceDate ? attendanceDate.toLocaleDateString() : 'N/A',
                                status: data.status,
                                meetingType: data.meetingType || 'General Meeting'
                            });
                        }
                    }

                    tableBody.innerHTML = '';
                    if (attendanceRecords.length === 0) {
                        infoText.textContent = `No attendance records found matching your criteria. Possible causes:
                          1. No data exists or no match.
                          2. Firestore rules are blocking access.
                          3. Missing a Collection Group index for 'attendance'.`;
                        tableBody.innerHTML = `<tr><td colspan="4" class="text-center text-gray-500">No attendance records found.</td></tr>`;
                        console.warn("No attendance found via collectionGroup query or after filtering.");
                        return;
                    }

                    infoText.textContent = `Displaying ${attendanceRecords.length} record(s).`;
                    attendanceRecords.forEach(record => {
                        const row = `
                            <tr>
                                <td>${record.dateString}</td>
                                <td>${record.memberName}</td>
                                <td>${record.status}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-danger px-3 py-1 text-sm delete-attendance-btn" data-member-id="${record.memberId}" data-id="${record.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${attendanceRecords.length} attendance records.`);
                }, (error) => {
                    console.error("Firestore listener error for admin attendance:", error);
                    showMessage("Failed to load attendance records due to an error.", "error");
                    infoText.textContent = "Error loading attendance records. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-attendance-btn')) {
                        const memberId = target.dataset.memberId;
                        const recordId = target.dataset.id;
                        const confirmed = await showCustomConfirm("Delete Attendance", "Are you sure you want to delete this attendance record?");
                        if (confirmed) {
                            await handleDeleteAttendance(memberId, recordId);
                        }
                    }
                });
            }

            async function loadAdminNotifications(sortBy = 'date', sortOrder = 'desc') {
                const tableBody = document.querySelector('#admin-notifications-table tbody');
                const infoText = document.getElementById('admin-notifications-table-info');
                if (!tableBody || !infoText) return;

                tableBody.innerHTML = '';
                infoText.textContent = "Loading notifications...";
                unsubscribeAllListeners();

                let q = query(collectionGroup(db, 'notifications'), orderBy(sortBy, sortOrder));

                const unsub = onSnapshot(q, async (snapshot) => {
                    let notifications = [];
                    for (const docSnapshot of snapshot.docs) {
                        const data = docSnapshot.data();
                        const recipientId = data.recipientId; // Can be a UID or "all"
                        let recipientName = "All Members";
                        if (recipientId && recipientId !== 'all') {
                            try {
                                const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(recipientId, 'user_profile'), recipientId));
                                if (profileDoc.exists()) {
                                    recipientName = profileDoc.data().name || profileDoc.data().email || recipientId;
                                } else {
                                    recipientName = `Specific User (${recipientId})`;
                                }
                            } catch (e) { console.warn("Could not fetch recipient name for ID:", recipientId, e); }
                        }

                        notifications.push({
                            id: docSnapshot.id,
                            recipientId: recipientId,
                            recipientName: recipientName,
                            title: data.title,
                            message: data.message,
                            date: data.date,
                            dateString: data.date ? new Date(data.date.seconds * 1000).toLocaleString() : 'N/A'
                        });
                    }

                    tableBody.innerHTML = '';
                    if (notifications.length === 0) {
                        infoText.textContent = `No notifications found. Possible causes:
                          1. No notifications have been sent yet.
                          2. Firestore rules are blocking access.
                          3. Missing a Collection Group index for 'notifications'.`;
                        tableBody.innerHTML = `<tr><td colspan="5" class="text-center text-gray-500">No notifications found.</td></tr>`;
                        console.warn("No notifications found via collectionGroup query.");
                        return;
                    }

                    infoText.textContent = `Displaying ${notifications.length} notification(s).`;
                    notifications.forEach(notif => {
                        const row = `
                            <tr>
                                <td>${notif.title}</td>
                                <td>${notif.message}</td>
                                <td>${notif.recipientName}</td>
                                <td>${notif.dateString}</td>
                                <td class="actions space-x-2">
                                    <button class="btn-danger px-3 py-1 text-sm delete-notification-btn" data-recipient-id="${notif.recipientId || 'all'}" data-id="${notif.id}"><i class="fas fa-trash"></i> Delete</button>
                                </td>
                            </tr>
                        `;
                        tableBody.innerHTML += row;
                    });
                    console.log(`Loaded ${notifications.length} notifications.`);
                }, (error) => {
                    console.error("Firestore listener error for admin notifications:", error);
                    showMessage("Failed to load notifications due to an error.", "error");
                    infoText.textContent = "Error loading notifications. Check console for details.";
                });
                unsubscribeListeners.push(unsub);

                // Attach table action listeners via event delegation
                tableBody.parentElement.addEventListener('click', async (event) => {
                    const target = event.target;
                    if (target.classList.contains('delete-notification-btn')) {
                        const notificationId = target.dataset.id;
                        const recipientId = target.dataset.recipientId; // Needed if notification is in user's subcollection
                        const confirmed = await showCustomConfirm("Delete Notification", "Are you sure you want to delete this notification?");
                        if (confirmed) {
                             if (recipientId === 'all') {
                                 // Delete from public notifications (if you had a public collection for them)
                                 // Currently, notifications are always private. So this 'all' logic is not fully used.
                                 // For now, it will delete from *first* recipient's notification if it were specific,
                                 // or from some hypothetical "admin" notification collection.
                                 // For true "all members" notification deletion, you'd need to track all recipients or use a public collection.
                                 showMessage("Deletion of 'All Members' notifications is complex as they are stored individually. Delete not implemented for this type.", "error");
                             } else {
                                await handleDeleteNotification(recipientId, notificationId);
                             }
                        }
                    }
                });
            }

            // --- Chart Display for Poll Results ---
            function displayPollResultsChart(poll) {
                const resultsContent = `
                    <h3 class="text-2xl font-bold text-maroon mb-4 text-center">Poll Results: ${poll.title}</h3>
                    <div class="chart-container" style="height: 300px;">
                        <canvas id="pollResultsChart"></canvas>
                    </div>
                    <div class="flex justify-center mt-4">
                        <button class="btn-secondary px-4 py-2" onclick="hideDataModal()">Close Results</button>
                    </div>
                `;
                openDataModal('Poll Results', 'results'); // Use a placeholder collection name
                dataModalForm.innerHTML = resultsContent; // Inject custom content
                dataModalSubmitBtn.classList.add('hidden'); // Hide Save button
                dataModalCancelBtn.classList.add('hidden'); // Hide Cancel button
                dataModalCloseBtn.classList.remove('hidden'); // Ensure close button is visible

                const ctx = document.getElementById('pollResultsChart').getContext('2d');
                const labels = Object.keys(poll.votes || {});
                const data = Object.values(poll.votes || {});

                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Votes',
                            data: data,
                            backgroundColor: [
                                var_primary_maroon, // Maroon
                                '#4CAF50', // Green
                                '#FFC107', // Amber
                                '#2196F3', // Blue
                                '#9C27B0'  // Purple
                            ],
                            borderColor: [
                                var_primary_maroon,
                                '#4CAF50',
                                '#FFC107',
                                '#2196F3',
                                '#9C27B0'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            // --- Admin Data Management (CRUD) Functions ---

            // Generic Modal Submit Handler
            async function handleDataModalSubmit() {
                if (!currentDataModalCollection) {
                    showMessage("Error: No collection specified for modal submit.", "error");
                    return;
                }

                const formData = {};
                let isValid = true;
                dataModalForm.querySelectorAll('input, select, textarea').forEach(field => {
                    if (field.type === 'file') {
                        formData[field.id] = field.files[0]; // Store the File object
                    } else if (field.type === 'checkbox') {
                         formData[field.id] = field.checked;
                    } else if (field.type === 'select-multiple') {
                        formData[field.id] = Array.from(field.selectedOptions).map(option => option.value);
                    }
                    else {
                        formData[field.id] = field.value;
                    }

                    if (field.required && !field.value && field.type !== 'file') { // File input can be empty if already existing URL
                        isValid = false;
                        showMessage(`Please fill out the "${field.previousElementSibling?.textContent || field.placeholder || field.id}" field.`, "error");
                        field.focus();
                    }
                    if (field.type === 'tel' && field.value && field.pattern && !new RegExp(field.pattern).test(field.value)) {
                         isValid = false;
                         showMessage(`Please enter a valid phone number (e.g., +254XXXXXXXXX).`, "error");
                         field.focus();
                    }
                });

                if (!isValid) return;

                // Handle specific logic based on collection
                try {
                    switch (currentDataModalCollection) {
                        case 'users':
                            await handleSaveMember(formData);
                            break;
                        case 'contributions':
                            await handleSaveContribution(formData);
                            break;
                        case 'loans':
                            await handleSaveLoan(formData);
                            break;
                        case 'meetings':
                            await handleSaveMeeting(formData);
                            break;
                        case 'investments':
                            await handleSaveInvestment(formData);
                            break;
                        case 'polls':
                            await handleSavePoll(formData);
                            break;
                        case 'documents':
                            await handleSaveDocument(formData);
                            break;
                        case 'fines':
                            await handleSaveFine(formData);
                            break;
                        case 'attendance':
                            await handleRecordBulkAttendance(formData);
                            break;
                        case 'notifications':
                            await handleComposeNotification(formData);
                            break;
                        default:
                            showMessage("Unknown collection type for saving.", "error");
                            return;
                    }
                    hideDataModal();
                } catch (error) {
                    console.error("Error saving data:", error);
                    showMessage(`Failed to save data: ${error.message}`, "error");
                }
            }


            // --- Member (User Profile) Management ---
            // NOTE: This handles both creating new users (with Auth) and updating existing Firestore profiles.
            async function handleSaveMember(formData) {
                const memberId = currentDataModalItem?.id; // If editing existing
                const email = formData['member-email'];
                const password = formData['member-password']; // Only for new users
                const name = formData['member-name'];
                const phone = formData['member-phone'];
                const nationalId = formData['member-national-id'];
                const profilePicUrl = formData['member-profile-pic'];
                const status = formData['member-status'];

                if (memberId) { // Editing existing user profile
                    // We only update the Firestore profile here. Firebase Auth email/password changes
                    // are handled separately in a real app, typically via a user's own settings.
                    const userProfileRef = doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId);
                    await updateDoc(userProfileRef, { name, phone, nationalId, profilePicUrl, status });
                    showMessage("Member profile updated successfully!", "success");
                } else { // Adding new member (Auth signup + Firestore profile)
                    try {
                        // Creating a new user via Auth from Admin Panel
                        const userCredential = await createUserWithEmailAndPassword(auth, email, password);
                        const newUser = userCredential.user;
                        const newUserProfileRef = doc(db, getPrivateCollectionPath(newUser.uid, 'user_profile'), newUser.uid);
                        await setDoc(newUserProfileRef, {
                            name, email, phone, nationalId, profilePicUrl, status,
                            createdAt: serverTimestamp(),
                            contribution_balance: 0,
                            loan_balance: 0,
                            next_meeting_date: "To be announced",
                            votes: {}, // Initialize votes object
                            investment_pledges: {} // Initialize investment pledges
                        });
                        showMessage("New member created and profile saved!", "success");
                    } catch (error) {
                        // Handle Auth errors specifically for signup
                        let errMsg = "Failed to add new member. ";
                        if (error.code === 'auth/email-already-in-use') errMsg += "Email already in use.";
                        else if (error.code === 'auth/weak-password') errMsg += "Password is too weak.";
                        else errMsg += error.message;
                        throw new Error(errMsg); // Re-throw to be caught by modal submit handler
                    }
                }
            }

            async function handleApproveUser(userId) {
                const confirmed = await showCustomConfirm("Approve User", `Are you sure you want to approve user ${userId}?`);
                if (!confirmed) return;
                const userProfileRef = doc(db, getPrivateCollectionPath(userId, 'user_profile'), userId);
                try {
                    await updateDoc(userProfileRef, { status: 'approved' });
                    showMessage(`User ${userId} approved successfully!`, "success");
                } catch (error) {
                    console.error("Error approving user:", error);
                    showMessage("Failed to approve user. Check console and rules.", "error");
                }
            }

            async function handleDeactivateUser(userId) {
                 const confirmed = await showCustomConfirm("Deactivate User", `Are you sure you want to deactivate user ${userId}? They will lose access.`);
                 if (!confirmed) return;
                 const userProfileRef = doc(db, getPrivateCollectionPath(userId, 'user_profile'), userId);
                 try {
                     await updateDoc(userProfileRef, { status: 'deactivated' });
                     showMessage(`User ${userId} deactivated successfully.`, "success");
                 } catch (error) {
                     console.error("Error deactivating user:", error);
                     showMessage("Failed to deactivate user. Check console and rules.", "error");
                 }
             }

            async function handleDeleteUser(userId) {
                const confirmed = await showCustomConfirm("Delete User", `Are you sure you want to DELETE user ${userId} and ALL their data? This action cannot be undone.`);
                if (!confirmed) return;
                try {
                    // This is complex! Deleting Auth user requires Admin SDK (backend).
                    // On frontend, you can only delete the Firestore profile.
                    // For full deletion, you'd need a Cloud Function.
                    // For now, only delete their profile data. Auth account will remain.
                    const userProfileRef = doc(db, getPrivateCollectionPath(userId, 'user_profile'), userId);
                    await deleteDoc(userProfileRef);
                    showMessage(`User profile for ${userId} deleted. (Firebase Auth account remains, contact support for full deletion).`, "success");
                } catch (error) {
                    console.error("Error deleting user profile:", error);
                    showMessage("Failed to delete user profile. Check console and rules.", "error");
                }
            }

            async function handleBulkApproveUsers() {
                const selectedCheckboxes = document.querySelectorAll('#users-table tbody input[type="checkbox"]:checked');
                if (selectedCheckboxes.length === 0) {
                    showMessage("No users selected for bulk approval.", "info");
                    return;
                }
                const confirmed = await showCustomConfirm("Bulk Approve", `Are you sure you want to approve ${selectedCheckboxes.length} selected user(s)?`);
                if (!confirmed) return;

                let approvedCount = 0;
                for (const checkbox of selectedCheckboxes) {
                    const userId = checkbox.dataset.userId;
                    try {
                        const userProfileRef = doc(db, getPrivateCollectionPath(userId, 'user_profile'), userId);
                        await updateDoc(userProfileRef, { status: 'approved' });
                        approvedCount++;
                    } catch (error) {
                        console.error(`Error approving user ${userId}:`, error);
                    }
                }
                showMessage(`Successfully approved ${approvedCount} user(s).`, "success");
            }

            async function handleBulkDeactivateUsers() {
                const selectedCheckboxes = document.querySelectorAll('#users-table tbody input[type="checkbox"]:checked');
                if (selectedCheckboxes.length === 0) {
                    showMessage("No users selected for bulk deactivation.", "info");
                    return;
                }
                const confirmed = await showCustomConfirm("Bulk Deactivate", `Are you sure you want to deactivate ${selectedCheckboxes.length} selected user(s)? They will lose access.`);
                if (!confirmed) return;

                let deactivatedCount = 0;
                for (const checkbox of selectedCheckboxes) {
                    const userId = checkbox.dataset.userId;
                    try {
                        const userProfileRef = doc(db, getPrivateCollectionPath(userId, 'user_profile'), userId);
                        await updateDoc(userProfileRef, { status: 'deactivated' });
                        deactivatedCount++;
                    } catch (error) {
                        console.error(`Error deactivating user ${userId}:`, error);
                    }
                }
                showMessage(`Successfully deactivated ${deactivatedCount} user(s).`, "success");
            }


            // --- Contributions Management ---
            async function handleSaveContribution(formData) {
                const contributionId = currentDataModalItem?.id; // If editing existing
                const memberId = formData['contribution-member-id'];
                const amount = parseFloat(formData['contribution-amount']);
                const method = formData['contribution-method'];
                const description = formData['contribution-description'];
                const date = new Date(formData['contribution-date']);

                const contributionRef = contributionId ?
                    doc(db, getPrivateCollectionPath(memberId, 'contributions'), contributionId) :
                    collection(db, getPrivateCollectionPath(memberId, 'contributions'));

                const userProfileRef = doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId);

                try {
                    await runTransaction(db, async (transaction) => {
                        const userDoc = await transaction.get(userProfileRef);
                        if (!userDoc.exists()) {
                            throw new Error("Member profile not found for this contribution.");
                        }
                        let newContributionBalance = userDoc.data().contribution_balance || 0;

                        if (contributionId) { // Edit existing
                            const oldContribution = currentDataModalItem;
                            newContributionBalance = newContributionBalance - oldContribution.amount + amount;
                            transaction.update(contributionRef, {
                                amount, method, description, date
                            });
                            showMessage("Contribution updated successfully!", "success");
                        } else { // Add new
                            newContributionBalance += amount;
                            transaction.add(contributionRef, {
                                memberId, amount, method, description, date: serverTimestamp(), status: 'completed'
                            });
                            showMessage("Contribution recorded successfully!", "success");
                        }
                        transaction.update(userProfileRef, { contribution_balance: newContributionBalance });
                    });
                } catch (error) {
                    throw new Error(`Failed to save contribution: ${error.message}`);
                }
            }

            async function handleDeleteContribution(memberId, contributionId) {
                const confirmed = await showCustomConfirm("Delete Contribution", `Are you sure you want to delete this contribution? This will also update the member's balance.`);
                if (!confirmed) return;

                const contributionRef = doc(db, getPrivateCollectionPath(memberId, 'contributions'), contributionId);
                const userProfileRef = doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId);

                try {
                    await runTransaction(db, async (transaction) => {
                        const contribDoc = await transaction.get(contributionRef);
                        if (!contribDoc.exists()) throw new Error("Contribution not found.");

                        const userDoc = await transaction.get(userProfileRef);
                        if (!userDoc.exists()) throw new Error("Member profile not found.");

                        const amountToRemove = contribDoc.data().amount;
                        const newContributionBalance = (userDoc.data().contribution_balance || 0) - amountToRemove;

                        transaction.delete(contributionRef);
                        transaction.update(userProfileRef, { contribution_balance: newContributionBalance });
                    });
                    showMessage("Contribution deleted successfully and member balance updated!", "success");
                } catch (error) {
                    console.error("Error deleting contribution:", error);
                    showMessage(`Failed to delete contribution: ${error.message}`, "error");
                }
            }


            // --- Loan Management ---
            async function handleSaveLoan(formData) {
                const loanId = currentDataModalItem?.id;
                const memberId = formData['loan-member-id'];
                const amount = parseFloat(formData['loan-amount']);
                const interestRate = parseFloat(formData['loan-interest-rate']);
                const dueDate = new Date(formData['loan-due-date']);
                const repaymentPlan = formData['loan-repayment-plan'];
                const purpose = formData['loan-purpose'];
                const status = formData['loan-status'];

                const loanCollection = collection(db, getPrivateCollectionPath(memberId, 'loans'));
                const loanRef = loanId ? doc(loanCollection, loanId) : null;
                const userProfileRef = doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId);

                try {
                    await runTransaction(db, async (transaction) => {
                        let newLoanBalance = (await transaction.get(userProfileRef)).data()?.loan_balance || 0;

                        if (loanId) { // Edit existing
                            const oldLoan = currentDataModalItem;
                            newLoanBalance = newLoanBalance - oldLoan.amount + amount; // Adjust balance
                            // Do not adjust if status changes to completed, assume repayment is handled separately
                            if (status === 'completed' && oldLoan.status !== 'completed') {
                                newLoanBalance = newLoanBalance - (oldLoan.amount - (oldLoan.repaidAmount || 0)); // Remove outstanding balance from total
                            }

                            transaction.update(loanRef, {
                                amount, interestRate, dueDate, repaymentPlan, purpose, status
                            });
                            showMessage("Loan updated successfully!", "success");
                        } else { // Add new
                            newLoanBalance += amount; // Add to balance immediately
                            transaction.add(loanCollection, {
                                memberId, amount, interestRate, dueDate, repaymentPlan, purpose, status,
                                timestamp: serverTimestamp(),
                                repaidAmount: 0
                            });
                            showMessage("Loan added successfully!", "success");
                        }
                        transaction.update(userProfileRef, { loan_balance: newLoanBalance });
                    });
                } catch (error) {
                    throw new Error(`Failed to save loan: ${error.message}`);
                }
            }


            // This function is already present and used by the "Repay" button, so no need to redefine
            // async function handleRecordLoanRepayment(memberId, loanId, amountRepaid) { ... }

            async function handleDeleteLoan(memberId, loanId) {
                const confirmed = await showCustomConfirm("Delete Loan", `Are you sure you want to delete this loan record? This will also update the member's balance.`);
                if (!confirmed) return;

                const loanRef = doc(db, getPrivateCollectionPath(memberId, 'loans'), loanId);
                const userProfileRef = doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId);

                try {
                    await runTransaction(db, async (transaction) => {
                        const loanDoc = await transaction.get(loanRef);
                        if (!loanDoc.exists()) throw new Error("Loan not found.");

                        const userDoc = await transaction.get(userProfileRef);
                        if (!userDoc.exists()) throw new Error("Member profile not found.");

                        const outstandingAmount = loanDoc.data().amount - (loanDoc.data().repaidAmount || 0);
                        const newLoanBalance = (userDoc.data().loan_balance || 0) - outstandingAmount;

                        transaction.delete(loanRef);
                        transaction.update(userProfileRef, { loan_balance: newLoanBalance });
                    });
                    showMessage("Loan deleted successfully and member balance updated!", "success");
                } catch (error) {
                    console.error("Error deleting loan:", error);
                    showMessage(`Failed to delete loan: ${error.message}`, "error");
                }
            }


            // --- Meetings & Notices Management ---
            async function handleSaveMeeting(formData) {
                const meetingId = currentDataModalItem?.id;
                const title = formData['meeting-title'];
                const date = new Date(formData['meeting-date']);
                const time = formData['meeting-time'];
                const location = formData['meeting-location'];
                const description = formData['meeting-description'];
                const type = formData['meeting-type'];

                const meetingsCollection = collection(db, getPublicCollectionPath('meetings'));
                const meetingRef = meetingId ? doc(meetingsCollection, meetingId) : null;

                if (meetingId) {
                    await updateDoc(meetingRef, { title, date, time, location, description, type });
                    showMessage("Meeting/Notice updated successfully!", "success");
                } else {
                    await addDoc(meetingsCollection, { title, date, time, location, description, type, createdAt: serverTimestamp() });
                    showMessage("Meeting/Notice added successfully!", "success");
                }
            }


            // --- Investments Management ---
            async function handleSaveInvestment(formData) {
                const investmentId = currentDataModalItem?.id;
                const title = formData['investment-title'];
                const amount = parseFloat(formData['investment-amount']);
                const description = formData['investment-description'];
                const estimatedReturn = formData['investment-estimated-return'];
                const status = formData['investment-status'];

                const investmentsCollection = collection(db, getPublicCollectionPath('investments'));
                const investmentRef = investmentId ? doc(investmentsCollection, investmentId) : null;

                if (investmentId) {
                    await updateDoc(investmentRef, { title, amount, description, estimatedReturn, status });
                    showMessage("Investment updated successfully!", "success");
                } else {
                    await addDoc(investmentsCollection, { title, amount, description, estimatedReturn, status, pledged: 0, createdAt: serverTimestamp() });
                    showMessage("Investment added successfully!", "success");
                }
            }

            async function handleMarkInvestmentCompleted(investmentId) {
                const confirmed = await showCustomConfirm("Mark Investment Completed", "Are you sure you want to mark this investment as 'completed'?");
                if (!confirmed) return;
                const investmentRef = doc(db, getPublicCollectionPath('investments'), investmentId);
                try {
                    await updateDoc(investmentRef, { status: 'completed' });
                    showMessage("Investment marked as completed!", "success");
                } catch (error) {
                    console.error("Error marking investment completed:", error);
                    showMessage("Failed to mark investment as completed.", "error");
                }
            }


            // --- Voting & Polls Management ---
            async function handleSavePoll(formData) {
                const pollId = currentDataModalItem?.id;
                const title = formData['poll-title'];
                const optionsInput = formData['poll-options'];
                const description = formData['poll-description'];
                const status = formData['poll-status'];

                const optionsArray = optionsInput.split(',').map(opt => opt.trim()).filter(opt => opt.length > 0);
                if (optionsArray.length < 2) {
                    throw new Error("Please provide at least two options for the poll.");
                }

                const pollsCollection = collection(db, getPublicCollectionPath('polls'));
                const pollRef = pollId ? doc(pollsCollection, pollId) : null;

                if (pollId) {
                    // When updating, preserve existing vote counts for options that are still present.
                    // New options get 0 votes. Removed options lose their votes.
                    const existingPoll = currentDataModalItem;
                    const newVotes = {};
                    optionsArray.forEach(opt => {
                        newVotes[opt] = existingPoll.votes?.[opt] || 0;
                    });
                    await updateDoc(pollRef, { title, options: optionsArray, description, status, votes: newVotes });
                    showMessage("Poll updated successfully!", "success");
                } else {
                    const votes = {};
                    optionsArray.forEach(option => { votes[option] = 0; });
                    await addDoc(pollsCollection, { title, options: optionsArray, description, votes, status, createdAt: serverTimestamp() });
                    showMessage("Poll created successfully!", "success");
                }
            }

            async function handleClosePoll(pollId) {
                const confirmed = await showCustomConfirm("Close Poll", "Are you sure you want to close this poll? Members will no longer be able to vote.");
                if (!confirmed) return;
                const pollRef = doc(db, getPublicCollectionPath('polls'), pollId);
                try {
                    await updateDoc(pollRef, { status: 'closed' });
                    showMessage("Poll closed successfully!", "success");
                } catch (error) {
                    console.error("Error closing poll:", error);
                    showMessage("Failed to close poll.", "error");
                }
            }


            // --- Documents Management ---
            async function handleSaveDocument(formData) {
                const documentId = currentDataModalItem?.id;
                const title = formData['document-title'];
                const fileInput = formData['document-file-input'];
                let fileUrl = formData['document-file-url']; // Direct URL if no file uploaded

                if (fileInput) { // If a file is selected for upload
                    const fileName = fileInput.name;
                    const storageRef = ref(storage, `documents/${title.replace(/\s/g, '_')}_${Date.now()}_${fileName}`);
                    try {
                        const snapshot = await uploadBytes(storageRef, fileInput);
                        fileUrl = await getDownloadURL(snapshot.ref);
                        showMessage("File uploaded to storage successfully!", "info");
                    } catch (error) {
                        console.error("Error uploading file to storage:", error);
                        throw new Error("Failed to upload file to storage. Please check permissions.");
                    }
                } else if (!fileUrl) { // If no file input and no direct URL provided
                    throw new Error("Either upload a file or provide a direct file URL.");
                }

                const documentsCollection = collection(db, getPublicCollectionPath('documents'));
                const documentRef = documentId ? doc(documentsCollection, documentId) : null;

                if (documentId) {
                    await updateDoc(documentRef, { title, fileUrl, uploadedAt: serverTimestamp(), uploadedBy: currentAdminEmail || 'Admin' }); // Use currentAdminEmail
                    showMessage("Document updated successfully!", "success");
                } else {
                    await addDoc(documentsCollection, { title, fileUrl, uploadedBy: currentAdminEmail || 'Admin', uploadedAt: serverTimestamp() }); // Use currentAdminEmail
                    showMessage("Document uploaded successfully!", "success");
                }
            }


            // --- Fines & Penalties Management ---
            async function handleSaveFine(formData) {
                const fineId = currentDataModalItem?.id;
                const memberId = formData['fine-member-id'];
                const amount = parseFloat(formData['fine-amount']);
                const reason = formData['fine-reason'];
                const status = formData['fine-status'];
                const dateIssued = new Date(formData['fine-date-issued']);

                const fineCollection = collection(db, getPrivateCollectionPath(memberId, 'fines'));
                const fineRef = fineId ? doc(fineCollection, fineId) : null;

                if (fineId) {
                    await updateDoc(fineRef, { memberId, amount, reason, status, dateIssued });
                    showMessage("Fine updated successfully!", "success");
                } else {
                    await addDoc(fineCollection, { memberId, amount, reason, status, dateIssued: serverTimestamp() });
                    showMessage("Fine issued successfully!", "success");
                }
            }

            async function handleBulkMarkFinesPaid() {
                const selectedCheckboxes = document.querySelectorAll('#all-fines-table tbody input[type="checkbox"]:checked');
                if (selectedCheckboxes.length === 0) {
                    showMessage("No fines selected for bulk marking as paid.", "info");
                    return;
                }
                const confirmed = await showCustomConfirm("Bulk Mark Paid", `Are you sure you want to mark ${selectedCheckboxes.length} selected fine(s) as 'paid'?`);
                if (!confirmed) return;

                let paidCount = 0;
                for (const checkbox of selectedCheckboxes) {
                    const fineId = checkbox.dataset.fineId;
                    const memberId = checkbox.dataset.memberId;
                    try {
                        const fineRef = doc(db, getPrivateCollectionPath(memberId, 'fines'), fineId);
                        await updateDoc(fineRef, { status: 'paid' });
                        paidCount++;
                    } catch (error) {
                        console.error(`Error marking fine ${fineId} as paid:`, error);
                    }
                }
                showMessage(`Successfully marked ${paidCount} fine(s) as paid.`, "success");
            }


            // --- Attendance Management ---
            async function handleRecordBulkAttendance(formData) {
                const meetingDate = new Date(formData['attendance-date']);
                const selectedMemberIds = formData['attendance-members'];

                if (!selectedMemberIds || selectedMemberIds.length === 0) {
                    showMessage("Please select at least one member to record attendance.", "error");
                    return;
                }

                let recordedCount = 0;
                for (const memberId of selectedMemberIds) {
                    const attendanceCollection = collection(db, getPrivateCollectionPath(memberId, 'attendance'));
                    try {
                        await addDoc(attendanceCollection, {
                            memberId,
                            date: meetingDate,
                            status: 'present',
                            recordedBy: currentAdminEmail || 'Admin', // Use currentAdminEmail
                            recordedAt: serverTimestamp()
                        });
                        recordedCount++;
                    } catch (error) {
                        console.error(`Error recording attendance for ${memberId}:`, error);
                    }
                }
                showMessage(`Recorded attendance for ${recordedCount} member(s) on ${meetingDate.toLocaleDateString()}.`, "success");
            }

            async function handleDeleteAttendance(memberId, attendanceId) {
                const confirmed = await showCustomConfirm("Delete Attendance", "Are you sure you want to delete this attendance record?");
                if (!confirmed) return;
                const attendanceRef = doc(db, getPrivateCollectionPath(memberId, 'attendance'), attendanceId);
                try {
                    await deleteDoc(attendanceRef);
                    showMessage("Attendance record deleted!", "success");
                } catch (error) {
                    console.error("Error deleting attendance record:", error);
                    showMessage("Failed to delete attendance record.", "error");
                }
            }

            async function exportAttendanceCsv() {
                const q = query(collectionGroup(db, 'attendance'), orderBy('date', 'desc'));
                const snapshot = await getDocs(q);
                let csvContent = "Date,Member Name,Status\n";

                for (const docSnapshot of snapshot.docs) {
                    const data = docSnapshot.data();
                    const memberId = data.memberId;
                    let memberName = `Unknown User (${memberId})`;
                    try {
                        const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                        if (profileDoc.exists()) {
                            memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                        }
                    } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }
                    const date = data.date ? new Date(data.date.seconds * 1000).toLocaleDateString() : 'N/A';
                    csvContent += `${date},"${memberName}",${data.status}\n`;
                }

                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.setAttribute('download', 'chama_attendance_report.csv');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showMessage("Attendance report exported successfully!", "success");
            }


            // --- Notifications Management ---
            async function handleComposeNotification(formData) {
                const title = formData['notification-subject'];
                const message = formData['notification-message'];
                const recipients = formData['notification-recipients']; // 'all-members' or 'specific-member'
                const specificMemberId = formData['notification-specific-member-id'];

                const notificationData = {
                    title: title,
                    message: message,
                    date: serverTimestamp(),
                    senderId: currentAdminEmail || 'Admin', // Use currentAdminEmail
                    status: 'unread'
                };

                if (recipients === 'all-members') {
                    // Fetch all user UIDs and send a notification to each one
                    const allUsersSnapshot = await getDocs(query(collectionGroup(db, 'user_profile')));
                    let sentCount = 0;
                    for (const userDoc of allUsersSnapshot.docs) {
                        const userId = userDoc.id;
                        try {
                            await addDoc(collection(db, getPrivateCollectionPath(userId, 'notifications')), {
                                ...notificationData,
                                recipientId: userId // Track individual recipient
                            });
                            sentCount++;
                        } catch (error) {
                            console.error(`Error sending notification to ${userId}:`, error);
                        }
                    }
                    showMessage(`Notification sent to ${sentCount} members!`, "success");
                } else if (recipients === 'specific-member' && specificMemberId) {
                    try {
                        await addDoc(collection(db, getPrivateCollectionPath(specificMemberId, 'notifications')), {
                            ...notificationData,
                            recipientId: specificMemberId
                        });
                        showMessage(`Notification sent to ${specificMemberId}!`, "success");
                    } catch (error) {
                        console.error(`Error sending notification to ${specificMemberId}:`, error);
                        showMessage("Failed to send notification to specific member. Check UID and permissions.", "error");
                    }
                } else {
                    showMessage("Invalid recipient selection for notification.", "error");
                    return;
                }
            }

            async function handleDeleteNotification(recipientId, notificationId) {
                const confirmed = await showCustomConfirm("Delete Notification", "Are you sure you want to delete this notification?");
                if (!confirmed) return;
                const notificationRef = doc(db, getPrivateCollectionPath(recipientId, 'notifications'), notificationId);
                try {
                    await deleteDoc(notificationRef);
                    showMessage("Notification deleted!", "success");
                } catch (error) {
                    console.error("Error deleting notification:", error);
                    showMessage("Failed to delete notification.", "error");
                }
            }

            // --- Report Generation ---
            function attachReportListeners() {
                document.getElementById('report-financial-statements')?.addEventListener('click', () => generateFinancialStatementsReport());
                document.getElementById('report-contributions-summary')?.addEventListener('click', () => generateContributionsSummaryReport());
                document.getElementById('report-loan-report')?.addEventListener('click', () => generateLoanReport());
                document.getElementById('report-fines-report')?.addEventListener('click', () => generateFinesReport());
                document.getElementById('report-attendance-report')?.addEventListener('click', () => exportAttendanceCsv()); // Reusing existing function
            }

            async function generateFinancialStatementsReport() {
                 showMessage("Generating financial statements report...", "info");
                 let csvContent = "Member Name,Email,Total Contributions (KSh),Total Loan Balance (KSh)\n";
                 try {
                     const usersSnapshot = await getDocs(collectionGroup(db, 'user_profile'));
                     for (const userDoc of usersSnapshot.docs) {
                         const userData = userDoc.data();
                         csvContent += `"${userData.name || 'N/A'}","${userData.email || 'N/A'}",${userData.contribution_balance?.toFixed(2) || '0.00'},${userData.loan_balance?.toFixed(2) || '0.00'}\n`;
                     }
                     downloadCsv(csvContent, 'chama_financial_statements_report.csv');
                     showMessage("Financial statements report generated!", "success");
                 } catch (error) {
                     console.error("Error generating financial statements report:", error);
                     showMessage("Failed to generate financial statements report. Check console and rules.", "error");
                 }
             }

            async function generateContributionsSummaryReport() {
                 showMessage("Generating contributions summary report...", "info");
                 let csvContent = "Member Name,Date,Amount (KSh),Method,Description\n";
                 try {
                     const contributionsSnapshot = await getDocs(query(collectionGroup(db, 'contributions'), orderBy('date', 'desc')));
                     for (const docSnapshot of contributionsSnapshot.docs) {
                         const data = docSnapshot.data();
                         const memberId = data.memberId;
                         let memberName = `Unknown User (${memberId})`;
                         try {
                             const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                             if (profileDoc.exists()) {
                                 memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                             }
                         } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }
                         const date = data.date ? new Date(data.date.seconds * 1000).toLocaleDateString() : 'N/A';
                         csvContent += `"${memberName}","${date}",${data.amount?.toFixed(2) || '0.00'},"${data.method || 'N/A'}","${data.description || 'N/A'}"\n`;
                     }
                     downloadCsv(csvContent, 'chama_contributions_summary_report.csv');
                     showMessage("Contributions summary report generated!", "success");
                 } catch (error) {
                     console.error("Error generating contributions summary report:", error);
                     showMessage("Failed to generate contributions summary report. Check console and rules.", "error");
                 }
             }

            async function generateLoanReport() {
                 showMessage("Generating loan report...", "info");
                 let csvContent = "Member Name,Loan ID,Amount (KSh),Interest Rate (%),Due Date,Repaid (KSh),Balance (KSh),Status,Purpose\n";
                 try {
                     const loansSnapshot = await getDocs(query(collectionGroup(db, 'loans'), orderBy('timestamp', 'desc')));
                     for (const docSnapshot of loansSnapshot.docs) {
                         const data = docSnapshot.data();
                         const memberId = data.memberId;
                         let memberName = `Unknown User (${memberId})`;
                         try {
                             const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                             if (profileDoc.exists()) {
                                 memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                             }
                         } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }
                         const dueDate = data.dueDate ? new Date(data.dueDate.seconds * 1000).toLocaleDateString() : 'N/A';
                         const balance = (data.amount - (data.repaidAmount || 0)).toFixed(2);
                         csvContent += `"${memberName}","${docSnapshot.id}",${data.amount?.toFixed(2) || '0.00'},${data.interestRate?.toFixed(1) || '0.0'},"${dueDate}",${data.repaidAmount?.toFixed(2) || '0.00'},${balance},"${data.status || 'N/A'}","${data.purpose || 'N/A'}"\n`;
                     }
                     downloadCsv(csvContent, 'chama_loan_report.csv');
                     showMessage("Loan report generated!", "success");
                 } catch (error) {
                     console.error("Error generating loan report:", error);
                     showMessage("Failed to generate loan report. Check console and rules.", "error");
                 }
            }

            async function generateFinesReport() {
                 showMessage("Generating fines report...", "info");
                 let csvContent = "Member Name,Date Issued,Amount (KSh),Reason,Status\n";
                 try {
                     const finesSnapshot = await getDocs(query(collectionGroup(db, 'fines'), orderBy('dateIssued', 'desc')));
                     for (const docSnapshot of finesSnapshot.docs) {
                         const data = docSnapshot.data();
                         const memberId = data.memberId;
                         let memberName = `Unknown User (${memberId})`;
                         try {
                             const profileDoc = await getDoc(doc(db, getPrivateCollectionPath(memberId, 'user_profile'), memberId));
                             if (profileDoc.exists()) {
                                 memberName = profileDoc.data().name || profileDoc.data().email || memberId;
                             }
                         } catch (e) { console.warn("Could not fetch member name for ID:", memberId, e); }
                         const dateIssued = data.dateIssued ? new Date(data.dateIssued.seconds * 1000).toLocaleDateString() : 'N/A';
                         csvContent += `"${memberName}","${dateIssued}",${data.amount?.toFixed(2) || '0.00'},"${data.reason || 'N/A'}","${data.status || 'N/A'}"\n`;
                     }
                     downloadCsv(csvContent, 'chama_fines_report.csv');
                     showMessage("Fines report generated!", "success");
                 } catch (error) {
                     console.error("Error generating fines report:", error);
                     showMessage("Failed to generate fines report. Check console and rules.", "error");
                 }
             }

            function downloadCsv(csvContent, filename) {
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.setAttribute('download', filename);
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            // --- Initial Load ---
            // onAuthStateChanged will handle the initial rendering based on admin status.
            // No explicit renderAdminSubpage call here in global scope.

            // Attach listeners to static elements that are always present after DOMContentLoaded
            // (e.g., sidebar items via event delegation on parent)
            document.getElementById('admin-sidebar').addEventListener('click', (event) => {
                const target = event.target.closest('.admin-sidebar-item');
                if (target && target.dataset.page) {
                    event.preventDefault(); // Prevent default link behavior if it's a direct hash link
                    renderAdminSubpage(target.dataset.page);
                }
            });

            // Handle URL hash changes for navigation (browser back/forward)
            window.addEventListener('hashchange', () => {
                const page = window.location.hash.substring(1) || 'admin-dashboard';
                // Only render if it's an admin dashboard page and an admin is logged in
                if (adminSubpages[page] && currentAdminId && currentAdminEmail) { // Simplified check, rely on onAuthStateChanged to set currentAdminEmail
                    renderAdminSubpage(page);
                } else if (!currentAdminId || !currentAdminEmail) {
                    // If not logged in or not admin, redirect to login page
                     window.location.replace(window.location.origin + '/index.html#login');
                }
            });
        });
    </script>
</body>
</html>
